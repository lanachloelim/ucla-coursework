["def likeComments(self,commentid,userid):\n        sqlText=\"insert into comment_like values(%s,%s);\"\n        result=sql.insertDB(self.conn, sqlText, (userid, commentid))\n        return result;", "```python\ndef add_inverters(self):\n    interfaces = self.config.get_connection_interfaces()\n    for source in interfaces:\n        if source[\"type\"] == \"inverter\":\n\n            query = '''\n                INSERT OR IGNORE INTO Inverters (\n                    Serial,\n                    EToday,\n                    ETotal\n                ) VALUES (\n                    ?,\n                    ?,\n                    ?\n                );\n            '''\n            self.c.execute(query, (source[\"serial_id\"], 0, source[\"prev_etotal\"]))\n\n            query = '''\n                UPDATE Inverters\n                SET     \n                    Name=?,\n                    Type=?,\n                    SW_Version=?,\n                    Status=?,\n                    TimeStamp=?\n                WHERE Serial=?;\n            '''\n            self.c.execute(query, (source[\"name\"], source[\"inverter_type\"], \"s0-bridge v0\", \"OK\", int(datetime.now().timestamp()), source[\"serial_id\"] ))\n\n            self.db.commit()\n```", "@mod.route('/delete/<int:msg_id>', methods=['GET', 'POST'])\ndef delete(msg_id):\n    if request.method == 'GET':\n        sql = \"DELETE FROM message where msg_id = %s;\"\n        cursor.execute(sql, (msg_id,))\n        conn.commit()\n        flash('Delete Success!')\n    return redirect(url_for('show_entries'))", "def karma_rank(name):\n    db = db_connect()\n    cursor = db.cursor()\n    try:\n        query = 'SELECT COUNT(*) FROM people AS t2 WHERE t2.karma > (SELECT karma FROM people WHERE name=%s)'\n        cursor.execute(query, (name,))\n        rank = cursor.fetchone()[0] + 1\n        logger.debug('Rank of {} found for name {}'.format(rank, name))\n        db.close()\n        return rank\n    except Exception as e:\n        logger.error('Execution failed with error: {}'.format(e))\n        raise", "def get_last_month(db, scene):\n    sql = \"select date from matches where scene=%s order by date desc limit 1;\"\n    res = db.exec(sql, (scene,))\n    date = res[0][0]\n\n    today = datetime.datetime.today().strftime('%Y-%m-%d')\n    y, m, d = today.split('-')\n    cy, cm, cd = date.split('-')\n    if int(y) > int(cy) or int(m) > int(cm):\n        date = get_next_month(date)\n\n    return date", "```python\n@app.route('/players/<int:player_id>/achievements')\ndef achievements_list_player(player_id):\n    \"\"\"Lists the progress of achievements for a player.\n\n    :param player_id: ID of the player.\n\n    :return:\n        If successful, this method returns a response body with the following structure::\n\n            {\n              \"items\": [\n                {\n                  \"achievement_id\": string,\n                  \"state\": string,\n                  \"current_steps\": integer,\n                  \"create_time\": long,\n                  \"update_time\": long\n                }\n              ]\n            }\n    \"\"\"\n    with db.connection:\n        cursor = db.connection.cursor(db.pymysql.cursors.DictCursor)\n        cursor.execute(\"\"\"SELECT\n                            achievement_id,\n                            current_steps,\n                            state,\n                            UNIX_TIMESTAMP(create_time) as create_time,\n                            UNIX_TIMESTAMP(update_time) as update_time\n                        FROM player_achievements\n                        WHERE player_id = %s\"\"\", (player_id,))\n\n        return flask.jsonify(items=cursor.fetchall())\n```", "def check_if_this_project_is_in_database(self, project_id):\n        self.cursor.execute(\"SELECT count(id) FROM projects where id = %s\", (project_id,))\n        return self.cursor.fetchall()[0][0] == 1", "@app.route(\"/<page_name>/edit\")\ndef edit_page(page_name):\n    query = db.query(\"select * from page where title = %s\", [page_name]).namedresult()\n    if len(query) == 0:\n        return render_template(\n            \"edit.html\",\n            page_name=page_name,\n            query=query\n        )\n    else:\n        return render_template(\n            \"edit.html\",\n            page_name=page_name,\n            query=query[0]\n        )", "def reportMatch(winner, loser):\n    conn = connect()\n    cursor = conn.cursor()\n    cursor.execute(\"INSERT INTO playsRecord (winner, loser) VALUES (?, ?)\", (winner, loser))\n    conn.commit()\n    conn.close()", "def get_game_info(conn, game):\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT player1,player2,size,state FROM games WHERE id = %s;\" % game)\n    if cursor.rowcount != 1:\n        raise FormError(\"Invalid game ID\")\n\n    row = cursor.fetchone()\n    players = [row[0],row[1]]\n    size    =  row[2]\n    state   =  row[3]\n\n    if state is None:\n         state = \"Active\"\n\n    cursor.close()\n\n    return (players,size,state)", "```python\nimport re\nimport pandas as pd\nimport datetime\nfrom logger import logger\nfrom db_utils import create_connection\n\ndef process_as_reply(email_obj):\n    job_number = email_obj['subject'].split(': #')[1]\n    feedback = re.findall(\"^[\\W]*([Oo\\d]){1}(?=[\\W]*)\", email_obj['content'].replace('#','').replace('link', ''))[0]\n    feedback = 1 if feedback.lower() == 'o' else int(feedback)\n    dcn_key = re.findall('\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}', email_obj['content'])[0]\n    logger.info(f\"got feedback `{feedback}` for job #`{job_number}`\")\n    \n    with create_connection() as conn:\n        was_prev_closed = pd.read_sql(f\"SELECT * FROM df_dilfo WHERE job_number={job_number}\", conn).iloc[0].closed\n\n    if was_prev_closed:\n        logger.info(f\"job was already matched successfully and logged as `closed`... skipping.\")\n        return\n\n    if feedback == 1:\n        logger.info(f\"got feedback that DCN key {dcn_key} was correct\")\n        update_status_query = \"UPDATE df_dilfo SET closed = 1 WHERE job_number = {}\"\n        \n        with create_connection() as conn:\n            conn.cursor().execute(update_status_query.format(job_number))\n            \n        logger.info(f\"updated df_dilfo to show `closed` status for job #{job_number}\")\n    \n    with create_connection() as conn:\n        df = pd.read_sql(\"SELECT * FROM df_matched\", conn)\n        match_dict_input = {\n            'job_number': job_number,\n            'dcn_key': dcn_key,\n            'ground_truth': 1 if feedback == 1 else 0,\n            'multi_phase': 1 if feedback == 2 else 0,\n            'verifier': email_obj[\"sender\"],\n            'source': 'feedback',\n            'log_date': str(datetime.datetime.now().date()),\n            'validate': 0,\n        }\n        df = df.append(match_dict_input, ignore_index=True)\n        df = df.drop_duplicates(subset=[\"job_number\", \"dcn_key\"], keep='last')\n        df.to_sql('df_matched', conn, if_exists='replace', index=False)\n        \n        logger.info(\n            f\"DCN key `{dcn_key}` was a \"\n            f\"{'successful match' if feedback == 1 else 'mis-match'} for job \"\n            f\"#{job_number}\"\n        )\n```", "def update_playlist(id, name, db):\n    db.execute(\n        \"UPDATE playlist SET name=? WHERE id=?\", (name, id))", "```python\n    def get_requested_month(self, date):\n        data = dict()\n\n        month_start, month_end = self.get_epoch_month(date)\n        data['interval'] = {'from': self.convert_local_ts_to_utc(month_start, self.local_timezone), 'to': self.convert_local_ts_to_utc(month_end, self.local_timezone)}\n        month_total = 0\n\n        query = '''\n            SELECT TimeStamp, SUM(DayYield) AS Power \n            FROM MonthData \n            WHERE TimeStamp BETWEEN ? AND ?\n            GROUP BY TimeStamp\n            '''\n\n        data['data'] = list()\n        # Changed query to use \"?\" as placeholders and pass parameters separately\n        for row in self.c.execute(query, (month_start, month_end)):\n            data['data'].append({'time': self.convert_local_ts_to_utc(row[0], self.local_timezone), 'power': row[1]})\n            month_total += row[1]\n\n        data['total'] = month_total\n\n        query = '''\n            SELECT MIN(TimeStamp) as Min, MAX(TimeStamp) as Max \n            FROM ( SELECT TimeStamp FROM MonthData GROUP BY TimeStamp );\n            '''\n\n        self.c.execute(query)\n        first_data, last_data = self.c.fetchone()\n\n        # Check for None instead of empty string or zero\n        if first_data is not None: data['hasPrevious'] = (first_data < month_start)\n        else: data['hasPrevious'] = False\n        if last_data is not None: data['hasNext'] = (last_data > month_end)\n        else: data['hasNext'] = False\n\n        return data\n```", "def retrieve_videos_from_playlist(playlist_id, db):\n    db.execute(\"SELECT id, title, thumbnail, position from video WHERE playlist_id=%s ORDER BY position ASC;\", (playlist_id,))\n    rows = db.fetchall()\n    return rows", "def create_playlist(name):\n    db = connect_to_database()\n    cursor = db.cursor()\n    cursor.execute(\n        \"INSERT INTO playlist (name, video_position) VALUES(%s, 0);\", (name,))\n    db.commit()\n    db.close()", "def update_video_positions(removed_position, db):\n    db.execute(\"UPDATE video SET position = position - 1 WHERE position > {removed_position}\".format(\n        removed_position=removed_position))\n    db.commit()", "Code:\n    @staticmethod\n    def _check_camera_tags(tags):\n        \"\"\"\n        Function that convert stupid code name of a smartphone or camera\n        from EXIF to meaningful one by looking a collation in a special MySQL\n        table For example instead of just Nikon there can be\n        NIKON CORPORATION in EXIF\n\n        :param tags: name of a camera and lens from EXIF\n        :return: list with one or two strings which are name of\n        camera and/or lens. If there is not better name for the gadget\n        in database, function just returns name how it is\n        \"\"\"\n        checked_tags = []\n\n        for tag in tags:\n            if tag:  # If there was this information inside EXIF of the photo\n                tag = str(tag).strip()\n                log.info('Looking up collation for %s', tag)\n                query = 'SELECT right_tag FROM tag_table WHERE wrong_tag=%s'\n                cursor = db.execute_query(query, (tag,))\n                if not cursor:\n                    log.error(\"Can't check the tag because of the db error\")\n                    log.warning(\"Tag will stay as is.\")\n                    continue\n                if cursor.rowcount:\n                    # Get appropriate tag from the table\n                    tag = cursor.fetchone()[0]\n                    log.info('Tag after looking up in tag_tables - %s.', tag)\n\n                checked_tags.append(tag)\n        \n        return checked_tags", "def add_input(self, data):\n\t\tconnection = self.connect()\n\t\ttry:\n\t\t\tquery = \"INSERT INTO crimes (description) VALUES(%s);\"\n\t\t\twith connection.cursor() as cursor:\n\t\t\t\tcursor.execute(query, (data,))\n\t\t\t\tconnection.commit()\n\t\tfinally:\n\t\t\tconnection.close()", "def getResults(poll_name):\n    conn, c = connectDB()\n    req = \"SELECT options from {} where name = %s\".format(CFG(\"poll_table_name\"))\n    c.execute(req, (poll_name,))\n    options_str = c.fetchone()\n\n    if not options_str:\n        raise LookupError(\"Poll '{}' not found in DB\".format(poll_name))\n\n    total = 0\n    options = options_str[0].split(\",\")\n    results = dict()\n    for opt in options:\n        count = getOptionCount(c, poll_name, opt)\n        total += int(count)\n        results.update({opt:count})\n\n    conn.close()\n    return (results, total)", "def update_sources(conn, sqlite, k10plus, ai):\n    \"\"\"\n    Update the source table.\n    \"\"\"\n    current_sources = get_all_current_sources(k10plus, ai)\n    old_sources = get_all_old_sources(conn, sqlite)\n\n    for old_source in old_sources:\n        if old_source not in current_sources:\n            message = \"Die SID %s ist im aktuellen Import nicht mehr vorhanden.\\nWenn dies beabsichtigt ist, bitte die SID aus der Datenbank loeschen.\" % old_source\n            send_message(message)\n\n    for current_source in current_sources:\n        if current_source not in old_sources:\n            message = \"The source %s is new in Solr.\" % current_source\n            logging.info(message)\n            sql = \"INSERT INTO source (source) VALUES (%s)\"\n            sqlite.execute(sql, (current_source,))\n            conn.commit()"]