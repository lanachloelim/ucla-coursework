["```python\ndef _get_3par_host(self, hostname):\n    out = self._cli_run(['showhost', '-verbose', hostname], None)\n    LOG.debug(\"OUTPUT = \\n%s\" % (pprint.pformat(out)))\n    host = {'id': None, 'name': None,\n            'domain': None,\n            'descriptors': {},\n            'iSCSIPaths': [],\n            'FCPaths': []}\n\n    if out:\n        err = out[0]\n        if err == 'no hosts listed':\n            msg = {'code': 'NON_EXISTENT_HOST',\n                   'desc': \"HOST '%s' was not found\" % hostname}\n            raise hpexceptions.HTTPNotFound(msg)\n\n        # start parsing the lines after the header line\n        for line in out[1:]:\n            if not line:\n                break\n            tmp = line.split(',')\n            paths = {}\n\n            LOG.debug(\"line = %s\" % (pprint.pformat(tmp)))\n            host['id'] = tmp[0]\n            host['name'] = tmp[1]\n\n            portPos = tmp[4]\n            LOG.debug(\"portPos = %s\" % (pprint.pformat(portPos)))\n            if portPos == '---':\n                portPos = None\n            else:\n                port = portPos.split(':')\n                portPos = {'node': int(port[0]), 'slot': int(port[1]),\n                           'cardPort': int(port[2])}\n\n            paths['portPos'] = portPos\n\n            # If FC entry\n            if tmp[5] == 'n/a':\n                paths['wwn'] = tmp[3]\n                host['FCPaths'].append(paths)\n            # else iSCSI entry\n            else:\n                paths['name'] = tmp[3]\n                paths['ipAddr'] = tmp[5]\n                host['iSCSIPaths'].append(paths)\n\n        # find the offset to the description stuff\n        offset = 0\n        for index, line in enumerate(out):\n            if line[:15] == '---------- Host':\n                offset = index\n                break\n\n        info = out[offset + 2]\n        tmp = info.split(':')\n        host['domain'] = tmp[1]\n\n        info = out[offset + 4]\n        tmp = info.split(':')\n        host['descriptors']['location'] = tmp[1]\n\n        info = out[offset + 5]\n        tmp = info.split(':')\n        host['descriptors']['ipAddr'] = tmp[1]\n\n        info = out[offset + 6]\n        tmp = info.split(':')\n        host['descriptors']['os'] = tmp[1]\n\n        info = out[offset + 7]\n        tmp = info.split(':')\n        host['descriptors']['model'] = tmp[1]\n\n        info = out[offset + 8]\n        tmp = info.split(':')\n        host['descriptors']['contact'] = tmp[1]\n\n        info = out[offset + 9]\n        tmp = info.split(':')\n        host['descriptors']['comment'] = tmp[1]\n\n    return host\n```", "def _get_vdisk_attributes(self, vdisk_name):\n        \"\"\"Return vdisk attributes, or None if vdisk does not exist\n\n        Exception is raised if the information from system can not be\n        parsed/matched to a single vdisk.\n        \"\"\"\n\n        ssh_cmd = ['svcinfo', 'lsvdisk', '-bytes', '-delim', '!', vdisk_name]\n        return self._execute_command_and_parse_attributes(ssh_cmd)", "```python\ndef git_hook(strict=False, modify=False):\n    \"\"\"\n    Git pre-commit hook to check staged files for isort errors\n\n    :param bool strict - if True, return number of errors on exit,\n        causing the hook to fail. If False, return zero so it will\n        just act as a warning.\n    :param bool modify - if True, fix the sources if they are not\n        sorted properly. If False, only report result without\n        modifying anything.\n\n    :return number of errors if in strict mode, 0 otherwise.\n    \"\"\"\n\n    # Get list of files modified and staged\n    diff_cmd = \"git diff-index --cached --name-only --diff-filter=ACMRTUXB HEAD\"\n    files_modified = get_lines(diff_cmd)\n\n    errors = 0\n    for filename in files_modified:\n        if filename.endswith('.py'):\n            # Get the staged contents of the file\n            staged_cmd = \"git show :%s\" % filename\n            staged_contents = get_output(staged_cmd)\n\n            sort = SortImports(\n                file_path=filename,\n                file_contents=staged_contents.decode(),\n                check=True\n            )\n\n            if sort.incorrectly_sorted:\n                errors += 1\n                if modify:\n                    sort.output(unified=True)\n\n    return errors if strict else 0\n```", "    def test_create_modify_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_NO_HOST_RET), ''])\n\n        create_host_cmd = ('createhost -iscsi -add fakehost '\n                           'iqn.1993-08.org.debian:01:222')\n        _run_ssh(create_host_cmd, False).AndReturn([CLI_CR, ''])\n        _run_ssh(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)", "```python\n    def _run_ssh(self, command, check_exit_code=True, attempts=1):\n        if not self.sshpool:\n            password = self.configuration.san_password\n            privatekey = self.configuration.san_private_key\n            min_size = self.configuration.ssh_min_pool_conn\n            max_size = self.configuration.ssh_max_pool_conn\n            self.sshpool = utils.SSHPool(self.configuration.san_ip,\n                                         self.configuration.san_ssh_port,\n                                         self.configuration.ssh_conn_timeout,\n                                         self.configuration.san_login,\n                                         password=password,\n                                         privatekey=privatekey,\n                                         min_size=min_size,\n                                         max_size=max_size)\n        last_exception = None\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                while attempts > 0:\n                    attempts -= 1\n                    try:\n                        return utils.ssh_execute(\n                            ssh,\n                            command,\n                            check_exit_code=check_exit_code)\n                    except Exception as e:\n                        LOG.error(str(e))\n                        last_exception = e\n                        greenthread.sleep(random.randint(20, 500) / 100.0)\n                try:\n                    raise exception.ProcessExecutionError(\n                        exit_code=getattr(last_exception, 'exit_code', -1),\n                        stdout=getattr(last_exception, 'stdout', \"\"),\n                        stderr=getattr(last_exception, 'stderr', \"Error running SSH command\"),\n                        cmd=command)\n                except:\n                    raise exception.ProcessExecutionError(\n                        exit_code=-1,\n                        stdout=\"\",\n                        stderr=\"Error running SSH command\",\n                        cmd=command)\n\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running SSH command: %s\") % command)\n```", "@app.route('/view/<path:sid>')\ndef view(sid): \n    if not \"/\" in sid:\n        path = os.path.join(app.config['UPLOAD_FOLDER'], sid) \n        if os.path.isdir(path): \n            using_firebase = 'true' if app.config['FIREBASE'] else 'false' \n            return render_template('view.html', sid=sid, title=\"Progress for %s\" % sid, using_firebase=using_firebase) \n        else: \n            abort(404) \n    else: \n        abort(403)", "def get_title_from_youtube_url(url):\n    try:\n        output = str(subprocess.check_output(['youtube-dl', '--get-title', url, '--no-warnings'], stderr=subprocess.STDOUT)).strip()\n    except subprocess.CalledProcessError as ex:\n        output = str(ex.output).strip()\n    except OSError as ex:\n        output = 'youtube-dl not found: %s' % ex\n    except Exception as ex:\n        output = 'Something bad happened: %s' % ex\n    return remove_commas_from_string(output)", "def test_get_ports(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_port_cmd = 'showport'\n        _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n        show_port_i_cmd = 'showport -iscsi'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                    ''])\n\n        show_port_i_cmd = 'showport -iscsiname'\n        _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI),\n                                                    ''])\n        self.mox.ReplayAll()\n\n        ports = self.driver.common.get_ports()\n        self.assertEqual(ports['FC'][0], '20210002AC00383D')\n        self.assertEqual(ports['iSCSI']['10.10.120.252']['nsp'], '0:8:2')", "def _create_3par_vlun(self, volume, hostname):\n        out = self._cli_run('createvlun %s auto %s' % (volume, hostname), None)\n        if out and len(out) > 1:\n            if \"must be in the same domain\" in out[0] or \"must be in the same domain\" in out[1]:\n                err = \" \".join(map(str.strip, out))\n                raise exception.Invalid3PARDomain(err=err)", "def _set_connections(self):\n        \"\"\"Set the number of concurrent connections.\n\n        The 3PAR WS API server has a limit of concurrent connections.\n        This is setting the number to the highest allowed, 15 connections.\n        \"\"\"\n        self._cli_run(\"setwsapi -sru high\", self._get_secure_parameter())", "```python\n    def _get_chap_secret_for_host(self, host_name):\n        \"\"\"Return the CHAP secret for the given host.\"\"\"\n\n        LOG.debug(_('enter: _get_chap_secret_for_host: host name %s')\n                  % host_name)\n\n        ssh_cmd = 'svcinfo lsiscsiauth -delim !'\n        out, err = self._run_ssh(ssh_cmd)\n\n        if not len(out.strip()):\n            return None\n\n        host_lines = out.strip().split('\\n')\n        self._assert_ssh_return(len(host_lines) >= 1, '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n\n        header = host_lines.pop(0).split('!')\n        self._assert_ssh_return('name' in header and 'iscsi_auth_method' in header\n                                and 'iscsi_chap_secret' in header,\n                                '_get_chap_secret_for_host', ssh_cmd, out, err)\n        name_index = header.index('name')\n        method_index = header.index('iscsi_auth_method')\n        secret_index = header.index('iscsi_chap_secret')\n\n        chap_secret = None\n        host_found = False\n        for line in host_lines:\n            info = line.split('!')\n            if info[name_index] == host_name and len(info) > max(name_index, method_index, secret_index):\n                host_found = True\n                if info[method_index] == 'chap':\n                    chap_secret = info[secret_index]\n\n        self._assert_ssh_return(host_found, '_get_chap_secret_for_host',\n                                ssh_cmd, out, err)\n\n        LOG.debug(_('leave: _get_chap_secret_for_host: host name '\n                    '%(host_name)s with secret %(chap_secret)s')\n                  % {'host_name': host_name, 'chap_secret': chap_secret})\n\n        return chap_secret\n```"]