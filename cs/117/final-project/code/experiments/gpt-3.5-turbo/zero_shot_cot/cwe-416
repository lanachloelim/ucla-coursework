["Code:\nstatic bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n    struct mmu_gather tlb;\n    struct vm_area_struct *vma;\n    bool ret = true;\n    \n    mutex_lock(&oom_lock);\n    \n    if (!down_read_trylock(&mm->mmap_sem)) {\n        ret = false;\n        trace_skip_task_reaping(tsk->pid);\n        goto unlock_oom;\n    }\n    \n    if (mm_has_notifiers(mm)) {\n        up_read(&mm->mmap_sem);\n        schedule_timeout_idle(HZ);\n        goto unlock_oom;\n    }\n    \n    if (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n        up_read(&mm->mmap_sem);\n        trace_skip_task_reaping(tsk->pid);\n        goto unlock_oom;\n    }\n    \n    trace_start_task_reaping(tsk->pid);\n    \n    set_bit(MMF_UNSTABLE, &mm->flags);\n    \n    tlb_gather_mmu(&tlb, mm, 0, -1);\n    for (vma = mm->mmap ; vma; vma = vma->vm_next) {\n        if (!can_madv_dontneed_vma(vma))\n            continue;\n        \n        if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n            unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end, NULL);\n    }\n    tlb_finish_mmu(&tlb, 0, -1);\n    pr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n            task_pid_nr(tsk), tsk->comm,\n            K(get_mm_counter(mm, MM_ANONPAGES)),\n            K(get_mm_counter(mm, MM_FILEPAGES)),\n            K(get_mm_counter(mm, MM_SHMEMPAGES)));\n    up_read(&mm->mmap_sem);\n    \n    trace_finish_task_reaping(tsk->pid);\nunlock_oom:\n    mutex_unlock(&oom_lock);\n    return ret;\n}", "static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n    GF_M2TS_Program *prog;\n    GF_M2TS_SECTION_ES *pmt;\n    u32 i, nb_progs, evt_type;\n    u32 nb_sections;\n    u32 data_size;\n    unsigned char *data;\n    GF_M2TS_Section *section;\n\n    /*wait for the last section */\n    if (!(status&GF_M2TS_TABLE_END)) return;\n\n    /*skip if already received*/\n    if (status&GF_M2TS_TABLE_REPEAT) {\n        if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n        return;\n    }\n\n    nb_sections = gf_list_count(sections);\n    if (nb_sections > 1) {\n        GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));\n        return;\n    }\n\n    section = (GF_M2TS_Section *)gf_list_get(sections, 0);\n    data = section->data;\n    data_size = section->data_size;\n\n    if (!(status&GF_M2TS_TABLE_UPDATE) && !gf_list_count(ts->programs)) {\n        if (ts->pat->demux_restarted) {\n            ts->pat->demux_restarted = 0;\n        } else {\n            GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));\n        }\n        return;\n    }\n    nb_progs = data_size / 4;\n\n    for (i=0; i<nb_progs; i++) {\n        u16 number, pid;\n        number = (data[0]<<8) | data[1];\n        pid = (data[2]&0x1f)<<8 | data[3];\n        data += 4;\n        if (number==0) {\n            if (!ts->nit) {\n                ts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n            }\n        } else {\n            GF_SAFEALLOC(prog, GF_M2TS_Program);\n            if (!prog) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));\n                return;\n            }\n            prog->streams = gf_list_new();\n            prog->pmt_pid = pid;\n            prog->number = number;\n            prog->ts = ts;\n            gf_list_add(ts->programs, prog);\n            GF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n            if (!pmt) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));\n                return;\n            }\n            pmt->flags = GF_M2TS_ES_IS_SECTION;\n            gf_list_add(prog->streams, pmt);\n            pmt->pid = prog->pmt_pid;\n            pmt->program = prog;\n            ts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n            pmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n        }\n    }\n\n    evt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n    if (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}", "```cpp\nstatic Image *ReadPWPImage(const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image = AcquireImage(image_info);\n  image = pwp_image;\n  status = OpenBlob(image_info, pwp_image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count = ReadBlob(pwp_image, 5, magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick, \"SFW95\", 5) !=0))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  read_info = CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info, (MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info, (void *) NULL, 0);\n  unique_file = AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c = ReadBlobByte(pwp_image); c != EOF; c = ReadBlobByte(pwp_image))\n    {\n      for (i = 0; i < 17; i++)\n        magick[i] = magick[i + 1];\n      magick[17] = (unsigned char) c;\n      if (LocaleNCompare((char *) (magick + 12), \"SFW94A\", 6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick + 12), \"SFW94A\", 6) != 0)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n    }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file = (FILE *) NULL;\n    if (unique_file != -1)\n      file = fdopen(unique_file, \"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      ThrowFileException(exception, FileOpenError, \"UnableToWriteFile\",\n        image->filename);\n      image = DestroyImageList(image);\n      return((Image *) NULL);\n    }\n    length = fwrite(\"SFW94A\", 1, 6, file);\n    (void) length;\n    filesize = 65535UL * magick[2] + 256L * magick[1] + magick[0];\n    for (i = 0; i < (ssize_t) filesize; i++)\n    {\n      c = ReadBlobByte(pwp_image);\n      (void) fputc(c, file);\n    }\n    (void) fclose(file);\n    next_image = ReadImage(read_info, exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename, MaxTextExtent,\n      \"slide_%02ld.sfw\",(long)next_image->scene);\n    if (image == (Image *) NULL)\n      image = next_image;\n    else\n    {\n      /*\n        Link image into image list.\n      */\n      for (p = image; p->next != (Image *) NULL; p = GetNextImageInList(p)) ;\n      next_image->previous = p;\n      next_image->scene = p->scene + 1;\n      p->next = next_image;\n    }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene + image_info->number_scenes - 1))\n        break;\n    status = SetImageProgress(image, LoadImagesTag, TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info = DestroyImageInfo(read_info);\n  (void) CloseBlob(pwp_image);\n  pwp_image = DestroyImage(pwp_image);\n  if (EOFBlob(image) != MagickFalse)\n  {\n    char\n      *message;\n\n    message = GetExceptionMessage(errno);\n    (void) ThrowMagickException(exception, GetMagickModule(), CorruptImageError,\n      \"UnexpectedEndOfFile\", \"`%s': %s\", image->filename, message);\n    message = DestroyString(message);\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n```", "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n\tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n\tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n\tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n\tunsigned int offset = doffset;\n\tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n\tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n\t\t\ti = 0;\n\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n\t\t\tfrag = skb_shinfo(list_skb)->frags;\n\t\t\tpos += skb_headlen(list_skb);\n\n\t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n\t\t\t\ti = 0;\n\t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n\t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n\n\t\t\t\tBUG_ON(!nfrags);\n\n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t*nskb_frag = *frag;\n\t\t\t__skb_frag_ref(nskb_frag);\n\t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}", "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == &usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "int blk_init_allocated_queue(struct request_queue *q)\n{\n    WARN_ON_ONCE(q->mq_ops);\n\n    q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n    if (!q->fq)\n        return -ENOMEM;\n\n    if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n        goto out_free_flush_queue;\n\n    if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n        goto out_exit_flush_rq;\n\n    INIT_WORK(&q->timeout_work, blk_timeout_work);\n    q->queue_flags        |= QUEUE_FLAG_DEFAULT;\n\n    /*\n     * This also sets hw/phys segments, boundary and size\n     */\n    blk_queue_make_request(q, blk_queue_bio);\n\n    q->sg_reserved_size = INT_MAX;\n\n    if (elevator_init(q))\n        goto out_exit_flush_rq;\n    return 0;\n\nout_exit_flush_rq:\n    if (q->exit_rq_fn)\n        q->exit_rq_fn(q, q->fq->flush_rq);\n    blk_free_flush_queue(q->fq);\n    return -ENOMEM;\n}", "int snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\terr = snd_timer_check_slave(timeri);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\t\ttimeri = NULL;\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\t/* open a master instance */\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (!list_empty(&timer->open_list)) {\n\t\ttimeri = list_entry(timer->open_list.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\terr = -EBUSY;\n\t\t\ttimeri = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (timer->num_instances >= timer->max_instances) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\t/* take a card refcount for safe disconnection */\n\tif (timer->card)\n\t\tget_device(&timer->card->card_dev);\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\n\tif (list_empty(&timer->open_list) && timer->hw.open) {\n\t\terr = timer->hw.open(timer);\n\t\tif (err) {\n\t\t\tkfree(timeri->owner);\n\t\t\tkfree(timeri);\n\t\t\ttimeri = NULL;\n\n\t\t\tif (timer->card)\n\t\t\t\tcard_dev_to_put = &timer->card->card_dev;\n\t\t\tmodule_put(timer->module);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tlist_add_tail(&timeri->open_list, &timer->open_list);\n\ttimer->num_instances++;\n\terr = snd_timer_check_master(timeri);\n\tif (err < 0) {\n\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\ttimeri = NULL;\n\t}\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\t*ti = timeri;\n\treturn err;\n}"]