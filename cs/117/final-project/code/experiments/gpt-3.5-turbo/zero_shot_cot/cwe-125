["```c\nsearch_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst bool need_to_append_dot = base_name[base_len - 1] == '.' ? false : true;\n\tstruct search_domain *dom;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + (need_to_append_dot ? 1 : 0) + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + (need_to_append_dot ? 1 : 0), postfix, postfix_len);\n\t\t\tnewname[base_len + (need_to_append_dot ? 1 : 0) + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL;\n}\n```", "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 1); // Fixing vulnerability by changing the last argument to 1\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n\n    return 1;\n}", "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n\n    stat(options->in_file, &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n\n    if (plist_out)\n    {\n        FILE *oplist = stdout; // Change to write to stdout by default\n        if (options->out_file != NULL)\n        {\n            oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n        }\n        fwrite(plist_out, sizeof(char), size, oplist);\n        \n        if (oplist != stdout) {\n            fclose(oplist);\n        }\n        \n        free(plist_out);\n    }\n    else\n    {\n        fprintf(stderr, \"ERROR: Failed to convert input file.\\n\"); // Print error message to stderr\n    }\n\n    free(options);\n    return 0;\n}", "```c\nszEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\nif (szEncryptedKey == NULL) {\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n...\ntmp_sa = (AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\nif (tmp_sa == NULL) {\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n...\nrc4_state_struct *rc4_state = crypt_rc4_init(new_key, sizeof(new_key));\nif (rc4_state == NULL) {\n    g_free(szEncryptedKey);\n    g_free(tmp_sa);\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n...\ndecrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey, key_bytes_len);\nif (decrypted_data == NULL) {\n    g_free(szEncryptedKey);\n    g_free(tmp_sa);\n    crypt_rc4_deinit(rc4_state);\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\n...\nguint8 *new_szEncryptedKey = g_malloc(key_len);\nif (new_szEncryptedKey == NULL) {\n    g_free(szEncryptedKey);\n    g_free(tmp_sa);\n    crypt_rc4_deinit(rc4_state);\n    g_free(decrypted_data);\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}\n\nmemcpy(new_szEncryptedKey, decrypted_data + key_index + 8, key_length);\ng_free(szEncryptedKey);\nszEncryptedKey = new_szEncryptedKey;\n\n...\nsa->key = &dummy_key;\n```", "```c\n  center=((ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+\n    GetPixelChannels(image)*(width/2));\n```", "INST_HANDLER (lds) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// Check if k is within bounds before accessing memory\n\tif(k >= 0 && k < sizeof(buf)) {\n\t\t// load value from RAMPD:k\n\t\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\t\tESIL_A (\"r%d,=,\", d);\n\t} else {\n\t\t// Handle out of bounds access\n\t\t// Add your error handling logic here\n\t}\n}", "```c\nstatic int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    unsigned int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i+7] * 256 + data[i+8];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i+7] * 256 + data[i+8];\n            }\n        }\n    }\n\n    return -1;\n}\n```", "static INLINE BOOL RLEDECOMPRESS(const BYTE* pbSrcBuffer, UINT32 cbSrcBuffer, BYTE* pbDestBuffer,\n                                 UINT32 rowDelta, UINT32 width, UINT32 height)\n{\n\tconst BYTE* pbSrc = pbSrcBuffer;\n\tconst BYTE* pbEnd;\n\tconst BYTE* pbDestEnd;\n\tBYTE* pbDest = pbDestBuffer;\n\tPIXEL temp;\n\tPIXEL fgPel = WHITE_PIXEL;\n\tBOOL fInsertFgPel = FALSE;\n\tBOOL fFirstLine = TRUE;\n\tBYTE bitmask;\n\tPIXEL pixelA, pixelB;\n\tUINT32 runLength;\n\tUINT32 code;\n\tUINT32 advance;\n\tRLEEXTRA\n\n\tif ((rowDelta == 0) || (rowDelta < width))\n\t\treturn FALSE;\n\n\tif (!pbSrcBuffer || !pbDestBuffer)\n\t\treturn FALSE;\n\n\tpbEnd = pbSrcBuffer + cbSrcBuffer;\n\tpbDestEnd = pbDestBuffer + rowDelta * height;\n\n\twhile (pbSrc < pbEnd)\n\t{\n\t\tif (fFirstLine)\n\t\t{\n\t\t\tif ((UINT32)(pbDest - pbDestBuffer) >= rowDelta)\n\t\t\t{\n\t\t\t\tfFirstLine = FALSE;\n\t\t\t\tfInsertFgPel = FALSE;\n\t\t\t}\n\t\t}\n\n\t\tcode = ExtractCodeId(*pbSrc);\n\n\t\tif (code == REGULAR_BG_RUN || code == MEGA_MEGA_BG_RUN)\n\t\t{\n\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\tif (fFirstLine)\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength = runLength - 1;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (fInsertFgPel)\n\t\t\t\t{\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\n\t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\trunLength--;\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfInsertFgPel = TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfInsertFgPel = FALSE;\n\n\t\tswitch (code)\n\t\t{\n\t\t\tcase REGULAR_FG_RUN:\n\t\t\tcase MEGA_MEGA_FG_RUN:\n\t\t\tcase LITE_SET_FG_FG_RUN:\n\t\t\tcase MEGA_MEGA_SET_FG_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN)\n\t\t\t\t{\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n\t\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n\t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase LITE_DITHERED_RUN:\n\t\t\tcase MEGA_MEGA_DITHERED_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\tSRCREADPIXEL(pixelB, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength * 2))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelB);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase REGULAR_COLOR_RUN:\n\t\t\tcase MEGA_MEGA_COLOR_RUN:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase REGULAR_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_FGBG_IMAGE:\n\t\t\tcase LITE_SET_FG_FGBG_IMAGE:\n\t\t\tcase MEGA_MEGA_SET_FGBG_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\n\t\t\t\tif (code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE)\n\t\t\t\t{\n\t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t}\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile (runLength > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\t\tpbSrc = pbSrc + 1;\n\t\t\t\t\t\tpbDest = WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, 8);\n\n\t\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\trunLength = runLength - 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (runLength > 0)\n\t\t\t\t{\n\t\t\t\t\tbitmask = *pbSrc;\n\t\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\t\tif (fFirstLine)\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpbDest =\n\t\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, runLength);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!pbDest)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase REGULAR_COLOR_IMAGE:\n\t\t\tcase MEGA_MEGA_COLOR_IMAGE:\n\t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n\t\t\t\tpbSrc = pbSrc + advance;\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tUNROLL(runLength, {\n\t\t\t\t\tSRCREADPIXEL(temp, pbSrc);\n\t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase SPECIAL_FGBG_1:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg1, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase SPECIAL_FGBG_2:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (fFirstLine)\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpbDest =\n\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg2, fgPel, 8);\n\t\t\t\t}\n\n\t\t\t\tif (!pbDest)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase SPECIAL_WHITE:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, WHITE_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\tcase SPECIAL_BLACK:\n\t\t\t\tpbSrc = pbSrc + 1;\n\n\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n\t\t\t\tDESTNEXTPIXEL(pbDest);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}", "```c\njas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n    jp2_box_t *box;\n    int found;\n    jas_image_t *image = NULL;\n    jp2_dec_t *dec = NULL;\n    bool samedtype;\n    int dtype;\n    unsigned int i;\n    jp2_cmap_t *cmapd;\n    jp2_pclr_t *pclrd;\n    jp2_cdef_t *cdefd;\n    unsigned int channo;\n    int newcmptno;\n    int_fast32_t *lutents;\n    jp2_cmapent_t *cmapent;\n    jas_icchdr_t icchdr;\n    jas_iccprof_t *iccprof;\n\n    dec = NULL;\n    box = NULL;\n\n    JAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n    dec = jp2_dec_create();\n    if (!dec) {\n        goto error;\n    }\n\n    /* Get the first box. This should be a JP box. */\n    box = jp2_box_get(in);\n    if (!box) {\n        jas_eprintf(\"error: cannot get box\\n\");\n        goto error;\n    }\n    if (box->type != JP2_BOX_JP) {\n        jas_eprintf(\"error: expecting signature box\\n\");\n        goto error;\n    }\n    if (box->data.jp.magic != JP2_JP_MAGIC) {\n        jas_eprintf(\"incorrect magic number\\n\");\n        goto error;\n    }\n    jp2_box_destroy(box);\n    box = NULL;\n\n    /* Get the second box. This should be a FTYP box. */\n    box = jp2_box_get(in);\n    if (!box) {\n        goto error;\n    }\n    if (box->type != JP2_BOX_FTYP) {\n        jas_eprintf(\"expecting file type box\\n\");\n        goto error;\n    }\n    jp2_box_destroy(box);\n    box = NULL;\n\n    /* Get more boxes... */\n    found = 0;\n    while ((box = jp2_box_get(in))) {\n        if (jas_getdbglevel() >= 1) {\n            jas_eprintf(\"got box type %s\\n\", box->info->name);\n        }\n        switch (box->type) {\n        case JP2_BOX_JP2C:\n            found = 1;\n            break;\n        case JP2_BOX_IHDR:\n            if (!dec->ihdr) {\n                dec->ihdr = box;\n                box = NULL;\n            }\n            break;\n        case JP2_BOX_BPCC:\n            if (!dec->bpcc) {\n                dec->bpcc = box;\n                box = NULL;\n            }\n            break;\n        case JP2_BOX_CDEF:\n            if (!dec->cdef) {\n                dec->cdef = box;\n                box = NULL;\n            }\n            break;\n        case JP2_BOX_PCLR:\n            if (!dec->pclr) {\n                dec->pclr = box;\n                box = NULL;\n            }\n            break;\n        case JP2_BOX_CMAP:\n            if (!dec->cmap) {\n                dec->cmap = box;\n                box = NULL;\n            }\n            break;\n        case JP2_BOX_COLR:\n            if (!dec->colr) {\n                dec->colr = box;\n                box = NULL;\n            }\n            break;\n        }\n        if (box) {\n            jp2_box_destroy(box);\n            box = NULL;\n        }\n        if (found) {\n            break;\n        }\n    }\n\n    if (!found) {\n        jas_eprintf(\"error: no code stream found\\n\");\n        goto error;\n    }\n\n    if (!(dec->image = jpc_decode(in, optstr))) {\n        jas_eprintf(\"error: cannot decode code stream\\n\");\n        goto error;\n    }\n\n    // Rest of the code remains the same\n}\n```", "static inline void get_conn_text(const conn *c, const int af, char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n\n    switch (af) {\n        case AF_INET:\n            inet_ntop(af, &((struct sockaddr_in *)sock_addr)->sin_addr, addr_text, sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = '[';\n            if (inet_ntop(af, &((struct sockaddr_in6 *)sock_addr)->sin6_addr, addr_text + 1, sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n\n        case AF_UNIX:\n            strncpy(addr_text, ((struct sockaddr_un *)sock_addr)->sun_path, sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n\n    if (strlen(addr_text) < 2) {\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n\n    if (port) {\n        snprintf(addr, MAXPATHLEN, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        snprintf(addr, MAXPATHLEN, \"%s:%s\", protoname, addr_text);\n    }\n}", "static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)\n{\n\t/* OpenSc Operation values for each command operation-type */\n\tconst int df_idx[8] = {\t /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/\n\t\tSC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\tSC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n\tconst int ef_idx[8] = {\n\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\tconst int efi_idx[8] = { /* internal EF used for RSA keys */\n\t\tSC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE,\n\t\tSC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE,\n\t\t-1, SC_AC_OP_ERASE, -1};\n\n\tu8\t\tbValue;\n\tint\t\ti;\n\tint\t\tiKeyRef = 0;\n\tint\t\tiMethod;\n\tint\t\tiPinCount;\n\tint\t\tiOffset = 0;\n\tint\t\tiOperation;\n\tconst int*\tp_idx;\n\n\t/* Check all sub-AC definitions within the total AC */\n\twhile (len > 1) {\t\t\t\t/* minimum length = 2 */\n\t\tsize_t iACLen   = buf[iOffset] & 0x0F;\n\t\tif (iACLen > len)\n\t\t\tbreak;\n\n\t\tiMethod = SC_AC_NONE;\t\t/* default no authentication required */\n\n\t\tif (buf[iOffset] & 0X80) { /* AC in adaptive coding */\n\t\t\t/* Evaluates only the command-byte, not the optional P1/P2/Option bytes */\n\t\t\tsize_t\tiParmLen = 1;\t\t\t/* command-byte is always present */\n\t\t\tsize_t\tiKeyLen  = 0;\t\t\t/* Encryption key is optional */\n\n\t\t\tif (buf[iOffset]   & 0x20) iKeyLen++;\n\t\t\tif (buf[iOffset+1] & 0x40) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x20) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x10) iParmLen++;\n\t\t\tif (buf[iOffset+1] & 0x08) iParmLen++;\n\n\t\t\t/* Get KeyNumber if available */\n\t\t\tif(iKeyLen) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1+(size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset+iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ){\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\t\t\t}\n\n\t\t\t/* Get PinNumber if available */\n\t\t\tif (iACLen > (1+iParmLen+iKeyLen)) {  /* check via total length if pin is present */\n\t\t\t\tif (len < 1+1+1+(size_t)iParmLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset+1+1+iParmLen];  /* PTL + AM-header + parameter-bytes */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Convert SETCOS command to OpenSC command group */\n\t\t\tif (len < 1+2)\n\t\t\t\tbreak;\n\t\t\tswitch(buf[iOffset+2]){\n\t\t\tcase 0x2A:\t\t\t/* crypto operation */\n\t\t\t\tiOperation = SC_AC_OP_CRYPTO;\n\t\t\t\tbreak;\n\t\t\tcase 0x46:\t\t\t/* key-generation operation */\n\t\t\t\tiOperation = SC_AC_OP_UPDATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tiOperation = SC_AC_OP_SELECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);\n\t\t}\n\t\telse { /* AC in simple coding */\n\t\t\t   /* Initial AC is treated as an operational AC */\n\n\t\t\t/* Get specific Cmd groups for specified file-type */\n\t\t\tswitch (file->type) {\n\t\t\tcase SC_FILE_TYPE_DF:            /* DF */\n\t\t\t\tp_idx = df_idx;\n\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   /* EF for RSA keys */\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         /* EF */\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen - 1;\t\t\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tiMethod = SC_AC_AUT;\t\t/* key authentication  */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tiMethod = SC_AC_PRO;\t\t/* secure messaging */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiKeyRef = iSC & 0x1F;\t\t\t/* get key number */\n\n\t\t\t\tiPinCount--;\t\t\t\t/* one byte used for keyReference  */\n\t\t\t}\n\n\t\t\t/* Pin present ? */\n\t\t\tif ( iPinCount > 0 ) {\n\t\t\t\tif (len < 1 + 2)\n\t\t\t\t\tbreak;\n\t\t\t\tiKeyRef = buf[iOffset + 2];\t/* pin ref */\n\t\t\t\tiMethod = SC_AC_CHV;\n\t\t\t}\n\n\t\t\t/* Add AC for each command-operationType into OpenSc structure */\n\t\t\tbValue = buf[iOffset + 1];\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif((bValue & 1) && (p_idx[i] >= 0))\n\t\t\t\t\tsc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);\n\t\t\t\tbValue >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Current field treated, get next AC sub-field */\n\t\tiOffset += iACLen +1;\t\t/* AC + PTL-byte */\n\t\tlen     -= iACLen +1;\n\t}\n}", "```c\n/*\n * Fixed do_core_note function to prevent buffer overflow vulnerability\n */\n\ndo_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n    int os_style = -1;\n    if (namesz >= 11 && memcmp(&nbuf[noff], \"NetBSD-CORE\", 11) == 0) {\n        os_style = OS_STYLE_NETBSD;\n    }\n\n    if (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n        if (file_printf(ms, \", %s-style\", os_style_names[os_style]) == -1) {\n            return 1;\n        }\n        *flags |= FLAGS_DID_CORE_STYLE;\n        *flags |= os_style;\n    }\n\n    switch (os_style) {\n    case OS_STYLE_NETBSD:\n        if (type == NT_NETBSD_CORE_PROCINFO) {\n            char sbuf[512];\n            struct NetBSD_elfcore_procinfo pi;\n            memset(&pi, 0, sizeof(pi));\n            memcpy(&pi, nbuf + doff, descsz);\n            if (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n                file_printable(sbuf, sizeof(sbuf), CAST(char *, pi.cpi_name)),\n                elf_getu32(swap, (uint32_t)pi.cpi_pid),\n                elf_getu32(swap, pi.cpi_euid),\n                elf_getu32(swap, pi.cpi_egid),\n                elf_getu32(swap, pi.cpi_nlwps),\n                elf_getu32(swap, (uint32_t)pi.cpi_siglwp),\n                elf_getu32(swap, pi.cpi_signo),\n                elf_getu32(swap, pi.cpi_sigcode)) == -1) {\n                return 1;\n            }\n\n            *flags |= FLAGS_DID_CORE;\n            return 1;\n        }\n        break;\n\n    default:\n        if (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n            size_t i, j;\n            unsigned char c;\n            for (i = 0; i < NOFFSETS; i++) {\n                unsigned char *cname, *cp;\n                size_t reloffset = prpsoffsets(i);\n                size_t noffset = doff + reloffset;\n                size_t k;\n                for (j = 0; j < 16; j++, noffset++, reloffset++) {\n                    if (noffset >= size)\n                        goto tryanother;\n\n                    if (reloffset >= descsz)\n                        goto tryanother;\n\n                    c = nbuf[noffset];\n                    if (c == '\\0') {\n                        if (j == 0)\n                            goto tryanother;\n                        else\n                            break;\n                    } else {\n                        if (!isprint(c) || isquote(c))\n                            goto tryanother;\n                    }\n                }\n\n                for (k = i + 1; k < NOFFSETS; k++) {\n                    size_t no;\n                    int adjust = 1;\n                    if (prpsoffsets(k) >= prpsoffsets(i))\n                        continue;\n                    for (no = doff + prpsoffsets(k); no < doff + prpsoffsets(i); no++)\n                        adjust = adjust && isprint(nbuf[no]);\n                    if (adjust)\n                        i = k;\n                }\n\n                cname = (unsigned char *)&nbuf[doff + prpsoffsets(i)];\n                for (cp = cname; *cp && isprint(*cp); cp++)\n                    continue;\n\n                while (cp > cname && isspace(cp[-1]))\n                    cp--;\n\n                if (file_printf(ms, \", from '%.*s'\", (int)(cp - cname), cname) == -1) {\n                    return 1;\n                }\n\n                *flags |= FLAGS_DID_CORE;\n                return 1;\n\n            tryanother:;\n            }\n        }\n        break;\n    }\n#endif\n    return 0;\n}\n```", "```c\n  /* Content Descriptor Count */\n  if (size < 2)\n    goto not_enough_data;\n\n  blockcount = gst_asf_demux_get_uint16 (&data, &size);\n\n  if (size < 0 || size < blockcount*4)\n    goto not_enough_data;\n\n  for (i = 1; i <= blockcount; ++i) {\n\t\n\t/* Descriptor */\n    if (!gst_asf_demux_get_string (&name, &name_len, &data, &size))\n      goto not_enough_data;\n\n    /* Descriptor Value Data Type */\n\tif (size < 0 || size < 2)\n      goto not_enough_data;\n    datatype = gst_asf_demux_get_uint16 (&data, &size);\n\n\t/* Descriptor Value (not really a string, but same thing reading-wise) */\n    if (!gst_asf_demux_get_string (&value, &value_len, &data, &size)) {\n      g_free (name);\n      goto not_enough_data;\n    }\n\n    if ((name_len == 0) || (value_len == 0))\n    {\n      g_free (name);\n\t  g_free (value);\n      continue;\n    }\n\n    /* Fix for integer overflow vulnerability */\n    gsize in, out;\n    gchar *name_utf8 = NULL;\n\t\n    name_utf8 = g_convert (name, name_len, \"UTF-8\", \"UTF-16LE\", &in, &out, NULL);\n    if (name_utf8 == NULL) {\n      g_free (name);\n      g_free (value);\n      continue;\n    }\n    \n      ...\n  }\n```", "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n\n  MessageReader output;\n  \n  // Fix for CWE-125 vulnerability: Validate the total_buffer_size to prevent integer overflow\n  if (total_buffer_size > SIZE_MAX) {\n      // handle the error and return -1\n      return -1;\n  }\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           /*match_exact_params=*/false);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n\n  // recvmsg() returns the number of characters received. On error, -1 is\n  // returned, with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto msg_name_extent = output.next();\n  // The returned |msg_namelen| should not exceed the buffer size.\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n\n  // A single buffer is passed from the untrusted side, copy it into the\n  // scattered buffers inside the enclave.\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n\n  auto msg_control_extent = output.next();\n  // The returned |msg_controllen| should not exceed the buffer size.\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n\n  return result;\n}", "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String& /*type*/ /* = null_string */,\n                         int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats = nullptr;\n\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS || stats == nullptr) {\n    free(stats);\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}"]