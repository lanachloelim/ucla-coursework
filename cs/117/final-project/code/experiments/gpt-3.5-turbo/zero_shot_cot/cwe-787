["static ssize_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate)\n{\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  unsigned char\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n  compact_pixels=(unsigned char *) NULL;\n  if (next_image->compression == RLECompression)\n    {\n      compact_pixels=AcquireCompactPixels(image);\n      if (compact_pixels == (unsigned char *) NULL)\n        return(0);\n    }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if (next_image->storage_class != PseudoClass)\n        {\n          if (IsGrayImage(next_image,&next_image->exception) == MagickFalse)\n            channels=next_image->colorspace == CMYKColorspace ? 4 : 3;\n          if (next_image->matte != MagickFalse)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if (next_image->storage_class == PseudoClass)\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n  else\n    {\n      if (IsGrayImage(next_image,&next_image->exception) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateImage(next_image,MagickFalse);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n            {\n              length=WritePSDChannel(psd_info,image_info,image,next_image,\n                BlackQuantum,compact_pixels,rows_offset,separate);\n              if (separate != MagickFalse)\n                size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n              else\n                rows_offset+=offset_length;\n              count+=length;\n            }\n        }\n      if (next_image->matte != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n    }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  if (next_image->colorspace == CMYKColorspace)\n    (void) NegateImage(next_image,MagickFalse);\n  if (separate != MagickFalse)\n    {\n      const char\n        *property;\n\n      property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n      if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            &image->exception);\n          if (mask != (Image *) NULL)\n          {\n            length=WritePSDChannel(psd_info,image_info,image,mask,\n              RedQuantum,compact_pixels,rows_offset,MagickTrue);\n            (void) WritePSDSize(psd_info,image,length,size_offset);\n            count+=length;\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n          }\n        }\n    }\n    return(count);\n}", "```c\nInitialiseRFBConnection(rfbClient* client)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  uint32_t authScheme;\n  uint32_t subAuthScheme;\n  rfbClientInitMsg ci;\n  \n  if (client->listenSpecified)\n    errorMessageOnReadFailure = FALSE;\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n  pv[sz_rfbProtocolVersionMsg]=0;\n\n  errorMessageOnReadFailure = TRUE;\n\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2) {\n    rfbClientLog(\"Not a valid VNC server (%s)\\n\",pv);\n    return FALSE;\n  }\n\n\n  DefaultSupportedMessages(client);\n  client->major = major;\n  client->minor = minor;\n\n  if ((major==rfbProtocolMajorVersion) && (minor>rfbProtocolMinorVersion))\n    client->minor = rfbProtocolMinorVersion;\n\n  if (major==3 && (minor==4 || minor==6)) {\n      rfbClientLog(\"UltraVNC server detected, enabling UltraVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  if (major==3 && (minor==14 || minor==16)) {\n     minor = minor - 10;\n     client->minor = minor;\n     rfbClientLog(\"UltraVNC Single Click server detected, enabling UltraVNC specific messages\\n\",pv);\n     DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  if (major==3 && minor==5) {\n      rfbClientLog(\"TightVNC server detected, enabling TightVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesTightVNC(client);\n  }\n\n  if ((major==3 && minor>8) || major>3)\n  {\n    client->major=3;\n    client->minor=8;\n  }\n\n  rfbClientLog(\"VNC server supports protocol version %d.%d (viewer %d.%d)\\n\",\n\t  major, minor, rfbProtocolMajorVersion, rfbProtocolMinorVersion);\n\n  sprintf(pv,rfbProtocolVersionFormat,client->major,client->minor);\n\n  if (!WriteToRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n\n\n  if (client->major==3 && client->minor > 6)\n  {\n    if (!ReadSupportedSecurityType(client, &authScheme, FALSE)) return FALSE;\n  }\n  else\n  {\n    if (!ReadFromRFBServer(client, (char *)&authScheme, 4)) return FALSE;\n    authScheme = rfbClientSwap32IfLE(authScheme);\n  }\n  \n  rfbClientLog(\"Selected Security Scheme %d\\n\", authScheme);\n  client->authScheme = authScheme;\n\n  switch (authScheme) {\n\n  case rfbConnFailed:\n    ReadReason(client);\n    return FALSE;\n\n  case rfbNoAuth:\n    rfbClientLog(\"No authentication needed\\n\");\n\n    if ((client->major==3 && client->minor > 7) || client->major>3)\n        if (!rfbHandleAuthResult(client)) return FALSE;        \n\n    break;\n\n  case rfbVncAuth:\n    if (!HandleVncAuth(client)) return FALSE;\n    break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  case rfbSASL:\n    if (!HandleSASLAuth(client)) return FALSE;\n    break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  case rfbMSLogon:\n#ifndef LIBVNCSERVER_WITH_CLIENT_GCRYPT\n    rfbClientLog(\"GCrypt support was not compiled in\\n\");\n    return FALSE;\n#else\n    if (!HandleMSLogonAuth(client)) return FALSE;\n#endif\n    break;\n\n  case rfbTLS:\n    if (!HandleAnonTLSAuth(client)) return FALSE;\n\n    if (!ReadSupportedSecurityType(client, &subAuthScheme, TRUE)) return FALSE;\n    client->subAuthScheme = subAuthScheme;\n\n    switch (subAuthScheme) {\n\n      case rfbConnFailed:\n        ReadReason(client);\n        return FALSE;\n\n      case rfbNoAuth:\n        rfbClientLog(\"No sub authentication needed\\n\");\n\n        if ((client->major==3 && client->minor > 7) || client->major>3)\n            if (!rfbHandleAuthResult(client)) return FALSE;\n        break;\n\n      case rfbVncAuth:\n        if (!HandleVncAuth(client)) return FALSE;\n        break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n      case rfbSASL:\n        if (!HandleSASLAuth(client)) return FALSE;\n        break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n      default:\n        rfbClientLog(\"Unknown sub authentication scheme from VNC server: %d\\n\",\n            (int)subAuthScheme);\n        return FALSE;\n    }\n\n    break;\n\n  case rfbVeNCrypt:\n    if (!HandleVeNCryptAuth(client)) return FALSE;\n\n    switch (client->subAuthScheme) {\n\n      case rfbVeNCryptTLSNone:\n      case rfbVeNCryptX509None:\n        rfbClientLog(\"No sub authentication needed\\n\");\n        if (!rfbHandleAuthResult(client)) return FALSE;\n        break;\n\n      case rfbVeNCryptTLSVNC:\n      case rfbVeNCryptX509VNC:\n        if (!HandleVncAuth(client)) return FALSE;\n        break;\n\n      case rfbVeNCryptTLSPlain:\n      case rfbVeNCryptX509Plain:\n        if (!HandlePlainAuth(client)) return FALSE;\n        break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n      case rfbVeNCryptX509SASL:\n      case rfbVeNCryptTLSSASL:\n        if (!HandleSASLAuth(client)) return FALSE;\n        break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n      default:\n        rfbClientLog(\"Unknown sub authentication scheme from VNC server: %d\\n\",\n            client->subAuthScheme);\n        return FALSE;\n    }\n\n    break;\n\n  default:\n    {\n      rfbBool authHandled=FALSE;\n      rfbClientProtocolExtension* e;\n      for (e = rfbClientExtensions; e; e = e->next) {\n        uint32_t const* secType;\n        if (!e->handleAuthentication) continue;\n        for (secType = e->securityTypes; secType && *secType; secType++) {\n          if (authScheme==*secType) {\n            if (!e->handleAuthentication(client, authScheme)) return FALSE;\n            if (!rfbHandleAuthResult(client)) return FALSE;\n            authHandled=TRUE;\n          }\n        }\n      }\n      if (authHandled) break;\n    }\n    rfbClientLog(\"Unknown authentication scheme from VNC server: %d\\n\",\n\t    (int)authScheme);\n    return FALSE;\n  }\n\n  ci.shared = (client->appData.shareDesktop ? 1 : 0);\n\n  if (!WriteToRFBServer(client,  (char *)&ci, sz_rfbClientInitMsg)) return FALSE;\n\n  if (!ReadFromRFBServer(client, (char *)&client->si, sz_rfbServerInitMsg)) return FALSE;\n\n  client->si.framebufferWidth = rfbClientSwap16IfLE(client->si.framebufferWidth);\n  client->si.framebufferHeight = rfbClientSwap16IfLE(client->si.framebufferHeight);\n  client->si.format.redMax = rfbClientSwap16IfLE(client->si.format.redMax);\n  client->si.format.greenMax = rfbClientSwap16IfLE(client->si.format.greenMax);\n  client->si.format.blueMax = rfbClientSwap16IfLE(client->si.format.blueMax);\n  client->si.nameLength = rfbClientSwap32IfLE(client->si.nameLength);\n\n  client->desktopName = malloc((uint64_t)client->si.nameLength + 1);\n  if (!client->desktopName) {\n    rfbClientLog(\"Error allocating memory for desktop name, %lu bytes\\n\",\n            (unsigned long)client->si.nameLength);\n    return FALSE;\n  }\n\n  if (!ReadFromRFBServer(client, client->desktopName, client->si.nameLength)) return FALSE;\n\n  client->desktopName[client->si.nameLength] = 0;\n\n  rfbClientLog(\"Desktop name \\\"%s\\\"\\n\",client->desktopName);\n\n  rfbClientLog(\"Connected to VNC server, using protocol version %d.%d\\n\",\n\t  client->major, client->minor);\n\n  rfbClientLog(\"VNC server default format:\\n\");\n  PrintPixelFormat(&client->si.format);\n\n  return TRUE;\n}\n```", "```\nint cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n    const cdf_section_header_t *shp;\n    cdf_section_header_t sh;\n    const uint8_t *p, *q, *e;\n    size_t i, o4, nelements, j, slen, left;\n    cdf_property_info_t *inp;\n\n    if (offs > UINT32_MAX / 4) {\n        errno = EFTYPE;\n        goto out;\n    }\n    shp = CAST(const cdf_section_header_t *,\n        cdf_offset(sst->sst_tab, offs));\n    if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n        goto out;\n    sh.sh_len = CDF_TOLE4(shp->sh_len);\n    if (sh.sh_len > CDF_SHLEN_LIMIT) {\n        errno = EFTYPE;\n        goto out;\n    }\n\n    if (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n        goto out;\n\n    sh.sh_properties = CDF_TOLE4(shp->sh_properties);\n    DPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n        sh.sh_properties));\n    if (sh.sh_properties > CDF_PROP_LIMIT)\n        goto out;\n    inp = cdf_grow_info(info, maxcount, sh.sh_properties);\n    if (inp == NULL)\n        goto out;\n    inp += *count;\n    *count += sh.sh_properties;\n    p = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n    e = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n    if (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n        goto out;\n\n    for (i = 0; i < sh.sh_properties; i++) {\n        if ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n            goto out;\n        inp[i].pi_id = CDF_GETUINT32(p, i << 1);\n        left = CAST(size_t, e - q);\n        if left < sizeof(uint32_t) {\n            DPRINTF((\"short info (no type)_\\n\"));\n            goto out;\n        }\n        inp[i].pi_type = CDF_GETUINT32(q, 0);\n        DPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n            i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n        if (inp[i].pi_type & CDF_VECTOR) {\n            if left < sizeof(uint32_t) * 2 {\n                DPRINTF((\"missing CDF_VECTOR length\\n\"));\n                goto out;\n            }\n            nelements = CDF_GETUINT32(q, 1);\n            if (nelements == 0) {\n                DPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n                goto out;\n            }\n            slen = 2;\n        } else {\n            nelements = 1;\n            slen = 1;\n        }\n        o4 = slen * sizeof(uint32_t);\n        if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED)) {\n            continue;\n        }\n\n        switch (inp[i].pi_type & CDF_TYPEMASK) {\n            case CDF_NULL:\n            case CDF_EMPTY:\n                break;\n            case CDF_SIGNED16:\n                if !cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)) {\n                    continue;\n                }\n                break;\n            case CDF_SIGNED32:\n            case CDF_BOOL:\n            case CDF_UNSIGNED32:\n            case CDF_FLOAT:\n                if !cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)) {\n                    continue;\n                }\n                break;\n            case CDF_SIGNED64:\n            case CDF_UNSIGNED64:\n            case CDF_DOUBLE:\n            case CDF_FILETIME:\n                if !cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)) {\n                    continue;\n                }\n                break;\n            case CDF_LENGTH32_STRING:\n            case CDF_LENGTH32_WSTRING:\n                if (nelements > 1) {\n                    size_t nelem = inp - *info;\n                    inp = cdf_grow_info(info, maxcount, nelements);\n                    if (inp == NULL) {\n                        goto out;\n                    }\n                    inp += nelem;\n                }\n                DPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n                    nelements));\n                for (j = 0; j < nelements && i < sh.sh_properties;\n                    j++, i++)\n                {\n                    uint32_t l;\n\n                    if (o4 + sizeof(uint32_t) > left) {\n                        goto out;\n                    }\n\n                    l = CDF_GETUINT32(q, slen);\n                    o4 += sizeof(uint32_t);\n                    if (o4 + l > left) {\n                        goto out;\n                    }\n\n                    inp[i].pi_str.s_len = l;\n                    inp[i].pi_str.s_buf = CAST(const char *,\n                        CAST(const void *, &q[o4]));\n\n                    DPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n                        SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n                        \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n                        left, inp[i].pi_str.s_buf));\n\n                    if (l & 1) {\n                        l++;\n                    }\n\n                    slen += l >> 1;\n                    o4 = slen * sizeof(uint32_t);\n                }\n                i--;\n                break;\n            case CDF_CLIPBOARD:\n                if (inp[i].pi_type & CDF_VECTOR) {\n                    continue;\n                }\n                break;\n            default:\n                unknown:\n                memset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n                DPRINTF((\"Don't know how to deal with %#x\\n\",\n                    inp[i].pi_type));\n                break;\n        }\n    }\n    return 0;\n\nout:\n    free(*info);\n    *info = NULL;\n    *count = 0;\n    *maxcount = 0;\n    errno = EFTYPE;\n    return -1;\n}\n```", "```c\nopj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    FILE *f = NULL;\n    int w, h, prec;\n    int i, numcomps, max;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */\n    opj_image_t * image = NULL;\n    int adjustS, ushift, dshift, force8;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n\n    char temp[32];\n    int bigendian;\n    opj_image_comp_t *comp = NULL;\n\n    numcomps = 1;\n    color_space = OPJ_CLRSPC_GRAY;\n\n    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));\n\n    max = 0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !\\n\", filename);\n        return NULL;\n    }\n\n    fseek(f, 0, SEEK_SET);\n    if (fscanf(f, \"PG%*[ \\t]%c%c%*[ \\t+-]%d%*[ \\t]%d%*[ \\t]%d\", &endian1,\n               &endian2, &prec, &w, &h) != 5) {\n        fclose(f);\n        fprintf(stderr,\n                \"ERROR: Failed to read the right number of element from the fscanf() function!\\n\");\n        return NULL;\n    }\n\n    fgetc(f);\n    if (endian1 == 'M' && endian2 == 'L') {\n        bigendian = 1;\n    } else if (endian2 == 'M' && endian1 == 'L') {\n        bigendian = 0;\n    } else {\n        fclose(f);\n        fprintf(stderr, \"Bad pgx header, please check input file\\n\");\n        return NULL;\n    }\n\n    /* initialize image component */\n\n    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +\n                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx\n                 + 1;\n    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +\n                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy\n                 + 1;\n\n    sign = '+';\n    while (*signtmp != '\\0') {\n        if (*signtmp == '-') {\n            sign = '-';\n            break;\n        }\n        signtmp++;\n    }\n\n    if (sign == '-') {\n        cmptparm.sgnd = 1;\n    } else {\n        cmptparm.sgnd = 0;\n    }\n    if (prec < 8) {\n        force8 = 1;\n        ushift = 8 - prec;\n        dshift = prec - ushift;\n        if (cmptparm.sgnd) {\n            adjustS = (1 << (prec - 1));\n        } else {\n            adjustS = 0;\n        }\n        cmptparm.sgnd = 0;\n        prec = 8;\n    } else {\n        ushift = dshift = force8 = adjustS = 0;\n    }\n\n    cmptparm.prec = (OPJ_UINT32)prec;\n    cmptparm.bpp = (OPJ_UINT32)prec;\n    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;\n    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = cmptparm.x0;\n    image->y0 = cmptparm.x0;\n    image->x1 = cmptparm.w;\n    image->y1 = cmptparm.h;\n\n    /* set image data */\n\n    comp = &image->comps[0];\n\n    for (i = 0; i < w * h; i++) {\n        int v;\n        if (force8) {\n            v = readuchar(f) + adjustS;\n            v = (v << ushift) + (v >> dshift);\n            comp->data[i] = (unsigned char)v;\n\n            if (v > max) {\n                max = v;\n            }\n\n            continue;\n        }\n        if (comp->prec == 8) {\n            if (!comp->sgnd) {\n                v = readuchar(f);\n            } else {\n                v = (char) readuchar(f);\n            }\n        } else if (comp->prec <= 16) {\n            if (!comp->sgnd) {\n                v = readushort(f, bigendian);\n            } else {\n                v = (short) readushort(f, bigendian);\n            }\n        } else {\n            if (!comp->sgnd) {\n                v = (int)readuint(f, bigendian);\n            } else {\n                v = (int) readuint(f, bigendian);\n            }\n        }\n        if (v > max) {\n            max = v;\n        }\n        comp->data[i] = v;\n    }\n    fclose(f);\n    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;\n\n    return image;\n}\n```", "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n         if ((length-(PSDQuantum(count)+12)-(q-datum)) < 0) \n        break;\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}"]