["```c\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    assert(p_cp != NULL);\n    assert(p_image != NULL);\n    if(p_tileno >= p_cp->tw * p_cp->th) {\n        return;\n    }\n\n    OPJ_UINT32  compno, resno;\n    const opj_tcp_t *l_tcp = NULL;\n    const opj_tccp_t * l_tccp = NULL;\n    const opj_image_comp_t * l_img_comp = NULL;\n\n    OPJ_UINT32 p, q;\n\n    l_tcp = &p_cp->tcps[p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n            \n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}\n```", "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n           }\n         }\n\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}", "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; // should never happen, but just in case of overflow!\n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  // On linux, we set STACK_BASE from `main`.\n  char ptr; // this is on the stack\n  extern void *STACK_BASE;\n  uintptr_t count =  (uintptr_t)((uintptr_t)STACK_BASE - (uintptr_t)&ptr);\n  return 1000000 - count; // give it 1 megabyte of stack\n#else\n  // stack depth seems pretty platform-specific :( Default to a value that disables it\n  return 1000000; // no stack depth check on this platform\n#endif\n}", "static int ssl_parse_client_psk_identity(mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end)\n{\n    int ret = 0;\n    size_t n;\n\n    if (ssl->conf->f_psk == NULL &&\n        (ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n            ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0))\n    {\n        MBEDTLS_SSL_DEBUG_MSG(1, (\"got no pre-shared key\"));\n        return(MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED);\n    }\n\n    if (*p + 2 > end)\n    {\n        MBEDTLS_SSL_DEBUG_MSG(1, (\"bad client key exchange message\"));\n        return(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE);\n    }\n\n    n = (size_t)((*p)[0] << 8) | (*p)[1];\n    *p += 2;\n\n    if (n < 1 || n > 65535 || *p + n > end)\n    {\n        MBEDTLS_SSL_DEBUG_MSG(1, (\"bad client key exchange message\"));\n        return(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE);\n    }\n\n    if (ssl->conf->f_psk != NULL)\n    {\n        if (ssl->conf->f_psk(ssl->conf->p_psk, ssl, *p, n) != 0)\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if (n != ssl->conf->psk_identity_len ||\n            memcmp(ssl->conf->psk_identity, *p, n) != 0)\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if (ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY)\n    {\n        MBEDTLS_SSL_DEBUG_BUF(3, \"Unknown PSK identity\", *p, n);\n        mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                       MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY);\n        return(MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY);\n    }\n\n    *p += n;\n\n    return(0);\n}", "```cpp\nbool read_ujpg( void )\n{\n    using namespace IOUtil;\n    using namespace Sirikata;\n\n    unsigned char ujpg_mrk[ 64 ];\n\n    write_byte_bill(Billing::HEADER, true, 24);\n\n    str_out->call_size_callback(max_file_size);\n\n    uint32_t compressed_header_size = 0;\n    if (ReadFull(str_in, ujpg_mrk, 4) != 4) {\n        custom_exit(ExitCode::SHORT_READ);\n    }\n    write_byte_bill(Billing::HEADER, true, 4);\n\n    compressed_header_size = LEtoUint32(ujpg_mrk);\n    if (compressed_header_size > 128 * 1024 * 1024 || max_file_size > 128 * 1024 * 1024) {\n        always_assert(false && \"Only support images < 128 megs\");\n        return false;\n    }\n    \n    bool pending_header_reads = false;\n    if (header_reader == NULL) {\n        std::vector<uint8_t, JpegAllocator<uint8_t> > compressed_header_buffer(compressed_header_size);\n        IOUtil::ReadFull(str_in, compressed_header_buffer.data(), compressed_header_buffer.size());\n        header_reader = new MemReadWriter((JpegAllocator<uint8_t>()));\n        \n        // Add seccomp here before decompression\n        \n        delete header_reader;\n        header_reader = nullptr;\n    } else {\n        always_assert(compressed_header_size == 0 && \"Special concatenation requires 0 size header\");\n    }\n    \n    grbs = sizeof(EOI);\n    grbgdata = EOI;\n\n    ReadFull(header_reader, ujpg_mrk, 3);\n\n    if (memcmp(ujpg_mrk, \"HDR\", 3) == 0) {\n        ReadFull(header_reader, ujpg_mrk, 4);\n        hdrs = LEtoUint32(ujpg_mrk);\n        hdrdata = (unsigned char*)aligned_alloc(hdrs);\n        memset(hdrdata, 0, hdrs);\n        if (hdrdata == NULL) {\n            fprintf(stderr, MEM_ERRMSG);\n            errorlevel.store(2);\n            return false;\n        }\n        ReadFull(header_reader, hdrdata, hdrs);\n    } else {\n        fprintf(stderr, \"HDR marker not found\");\n        errorlevel.store(2);\n        return false;\n    }\n\n    bool memory_optimized_image = (filetype != UJG) && !g_allow_progressive;\n    if (!setup_imginfo_jpg(memory_optimized_image))\n        return false;\n\n    ReadFull(header_reader, ujpg_mrk, 3);\n    \n    // Add seccomp here before reading padbit information\n    \n    delete header_reader;\n    header_reader = nullptr;\n\n    // Add seccomp here before returning a value\n    \n    return true;\n}\n```"]