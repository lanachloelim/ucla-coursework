["def _get_3par_host(self, hostname):\n    out = self._cli_run(['showhost', '-verbose', hostname], None)\n    host = {'id': None, 'name': None,\n            'domain': None,\n            'descriptors': {},\n            'iSCSIPaths': [],\n            'FCPaths': []}\n\n    if out:\n        err = out[0]\n        if err == 'no hosts listed':\n            msg = {'code': 'NON_EXISTENT_HOST',\n                   'desc': \"HOST '%s' was not found\" % hostname}\n            raise hpexceptions.HTTPNotFound(msg)\n\n        for line in out[1:]:\n            if line == '':\n                break\n\n            tmp = line.split(',')\n            paths = {}\n\n            host['id'] = tmp[0]\n            host['name'] = tmp[1]\n\n            portPos = tmp[4]\n            if portPos == '---':\n                portPos = None\n            else:\n                port = portPos.split(':')\n                portPos = {'node': int(port[0]), 'slot': int(port[1]),\n                           'cardPort': int(port[2])}\n\n            paths['portPos'] = portPos\n\n            if tmp[5] == 'n/a':\n                paths['wwn'] = tmp[3]\n                host['FCPaths'].append(paths)\n            else:\n                paths['name'] = tmp[3]\n                paths['ipAddr'] = tmp[5]\n                host['iSCSIPaths'].append(paths)\n\n        # find the offset to the description stuff\n        offset = 0\n        for idx, line in enumerate(out):\n            if line[:15] == '---------- Host':\n                offset = idx\n                break\n\n        host['domain'] = out[offset + 2].split(':')[1]\n        host['descriptors']['location'] = out[offset + 4].split(':')[1]\n        host['descriptors']['ipAddr'] = out[offset + 5].split(':')[1]\n        host['descriptors']['os'] = out[offset + 6].split(':')[1]\n        host['descriptors']['model'] = out[offset + 7].split(':')[1]\n        host['descriptors']['contact'] = out[offset + 8].split(':')[1]\n        host['descriptors']['comment'] = out[offset + 9].split(':')[1]\n\n    return host", "def _get_vdisk_attributes(self, vdisk_name):\n        \"\"\"Return vdisk attributes, or None if vdisk does not exist\n\n        Exception is raised if the information from system can not be\n        parsed/matched to a single vdisk.\n        \"\"\"\n\n        ssh_cmd = ['svcinfo', 'lsvdisk', '-bytes', '-delim', '!', vdisk_name]\n        return self._execute_command_and_parse_attributes(ssh_cmd)", "def git_hook(strict=False, modify=False):\n    \"\"\"\n    Git pre-commit hook to check staged files for isort errors\n\n    :param bool strict - if True, return number of errors on exit,\n        causing the hook to fail. If False, return zero so it will\n        just act as a warning.\n    :param bool modify - if True, fix the sources if they are not\n        sorted properly. If False, only report result without\n        modifying anything.\n\n    :return number of errors if in strict mode, 0 otherwise.\n    \"\"\"\n    \n    import subprocess\n    # Get list of files modified and staged\n    diff_cmd = [\"git\", \"diff-index\", \"--cached\", \"--name-only\", \"--diff-filter=ACMRTUXB\", \"HEAD\"]\n    files_modified = subprocess.check_output(diff_cmd).decode().splitlines()\n\n    errors = 0\n    for filename in files_modified:\n        if filename.endswith('.py'):\n            # Get the staged contents of the file\n            staged_cmd = [\"git\", \"show\", \":%s\" % filename]\n            staged_contents = subprocess.check_output(staged_cmd).decode()\n\n            sort = SortImports(\n                file_path=filename,\n                file_contents=staged_contents,\n                check=True\n            )\n\n            if sort.incorrectly_sorted:\n                errors += 1\n                if modify:\n                    SortImports(\n                        file_path=filename,\n                        file_contents=staged_contents,\n                        check=False,\n                    )\n\n    return errors if strict else 0", "def test_create_modify_host(self):\n        self.flags(lock_path=self.tempdir)\n\n        #record\n        self.clear_mox()\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_cpg\",\n                       self.fake_get_cpg)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"get_domain\",\n                       self.fake_get_domain)\n        _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n        self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n        show_host_cmd = 'showhost -verbose fakehost'\n        _run_ssh.assert_command(show_host_cmd, False).AndReturn([pack(ISCSI_NO_HOST_RET), ''])\n\n        create_host_cmd = ('createhost -iscsi -add fakehost '\n                           'iqn.1993-08.org.debian:01:222')\n        _run_ssh.assert_command(create_host_cmd, False).AndReturn([CLI_CR, ''])\n        _run_ssh.assert_command(show_host_cmd, False).AndReturn([pack(ISCSI_HOST_RET), ''])\n        self.mox.ReplayAll()\n\n        host = self.driver._create_host(self.volume, self.connector)\n        self.assertEqual(host['name'], self.FAKE_HOST)", "def _run_ssh(self, command, check_exit_code=True, attempts=1):\n        if not self.sshpool:\n            password = self.configuration.san_password\n            privatekey = self.configuration.san_private_key\n            min_size = self.configuration.ssh_min_pool_conn\n            max_size = self.configuration.ssh_max_pool_conn\n            self.sshpool = utils.SSHPool(self.configuration.san_ip,\n                                         self.configuration.san_ssh_port,\n                                         self.configuration.ssh_conn_timeout,\n                                         self.configuration.san_login,\n                                         password=password,\n                                         privatekey=privatekey,\n                                         min_size=min_size,\n                                         max_size=max_size)\n        last_exception = None\n        try:\n            total_attempts = attempts\n            with self.sshpool.item() as ssh:\n                for _ in range(attempts):\n                    try:\n                        return utils.ssh_execute(\n                            ssh,\n                            command,\n                            check_exit_code=check_exit_code)\n                    except Exception as e:\n                        LOG.error(e)\n                        last_exception = e\n                        greenthread.sleep(random.randint(20, 500) / 100.0)\n                try:\n                    raise exception.ProcessExecutionError(\n                        exit_code=last_exception.exit_code,\n                        stdout=last_exception.stdout,\n                        stderr=last_exception.stderr,\n                        cmd=last_exception.cmd)\n                except AttributeError:\n                    raise exception.ProcessExecutionError(\n                        exit_code=-1,\n                        stdout=\"\",\n                        stderr=\"Error running SSH command\",\n                        cmd=command)\n\n        except Exception as exc:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_(\"Error running SSH command: %s\") % command)", "@app.route('/view/<path:sid>')\ndef view(sid):\n    if '/' not in sid:\n        path = os.path.join(app.config['UPLOAD_FOLDER'], sid)\n        if os.path.isdir(path):\n            using_firebase = 'true' if app.config['FIREBASE'] else 'false'\n            return render_template('view.html',\n            sid=sid, title=\"Progress for %s\" % sid, using_firebase=using_firebase)\n        else:\n            abort(404)\n    else:\n        abort(403)", "import requests\nfrom bs4 import BeautifulSoup\n\ndef get_title_from_youtube_url(url):\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.text, 'html.parser')\n        title = soup.title.string\n    except requests.exceptions.RequestException as ex:\n        title = 'Error fetching the title: %s' % ex\n    except Exception as ex:\n        title = 'Something bad happened: %s' % ex\n    return remove_commas_from_string(title)", "def test_get_ports(self):\n    self.flags(lock_path=self.tempdir)\n\n    #record\n    self.clear_mox()\n    _run_ssh = self.mox.CreateMock(hpdriver.hpcommon.HP3PARCommon._run_ssh)\n    self.stubs.Set(hpdriver.hpcommon.HP3PARCommon, \"_run_ssh\", _run_ssh)\n\n    show_port_cmd = 'showport'\n    _run_ssh(show_port_cmd, False).AndReturn([pack(PORT_RET), ''])\n\n    show_port_i_cmd = 'showport -iscsi'\n    _run_ssh(show_port_i_cmd, False).AndReturn([pack(READY_ISCSI_PORT_RET),\n                                                ''])\n\n    show_port_i_cmd = 'showport -iscsiname'\n    _run_ssh(show_port_i_cmd, False).AndReturn([pack(SHOW_PORT_ISCSI),\n                                                ''])\n    self.mox.ReplayAll()\n\n    ports = self.driver.common.get_ports()\n    self.assertEqual(ports['FC'][0], '20210002AC00383D')\n    self.assertEqual(ports['iSCSI']['10.10.120.252']['nsp'], '0:8:2')", "def _create_3par_vlun(self, volume, hostname):\n    cmd = ['createvlun', volume, 'auto', hostname]\n    out = self._cli_run(cmd, None)\n    if out and len(out) > 1:\n        if \"must be in the same domain\" in out[0]:\n            err = ' '.join(out).strip()\n            raise exception.Invalid3PARDomain(err=err)", "def _set_connections(self):\n        \"\"\"Set the number of concurrent connections.\n\n        The 3PAR WS API server has a limit of concurrent connections.\n        This is setting the number to the highest allowed, 15 connections.\n        \"\"\"\n        self._cli_run(\"setwsapi -sru high\", None)", "def _get_chap_secret_for_host(self, host_name):\n    \"\"\"Return the CHAP secret for the given host.\"\"\"\n\n    LOG.debug('enter: _get_chap_secret_for_host: host name %s'\n              % host_name)\n\n    ssh_cmd = ['svcinfo', 'lsiscsiauth', '-delim', '!']\n    out, err = self._run_ssh(ssh_cmd)\n\n    if not out:\n        return None\n\n    host_lines = out.strip().split('\\n')\n    self._assert_ssh_return(len(host_lines), '_get_chap_secret_for_host',\n                            ssh_cmd, out, err)\n\n    header = host_lines.pop(0).split('!')\n    self._assert_ssh_return('name' in header, '_get_chap_secret_for_host',\n                            ssh_cmd, out, err)\n    self._assert_ssh_return('iscsi_auth_method' in header,\n                            '_get_chap_secret_for_host', ssh_cmd, out, err)\n    self._assert_ssh_return('iscsi_chap_secret' in header,\n                            '_get_chap_secret_for_host', ssh_cmd, out, err)\n    name_index = header.index('name')\n    method_index = header.index('iscsi_auth_method')\n    secret_index = header.index('iscsi_chap_secret')\n\n    chap_secret = None\n    host_found = False\n    for line in host_lines:\n        info = line.split('!')\n        if info[name_index] == host_name:\n            host_found = True\n            if info[method_index] == 'chap':\n                chap_secret = info[secret_index]\n\n    self._assert_ssh_return(host_found, '_get_chap_secret_for_host',\n                            ssh_cmd, out, err)\n\n    LOG.debug('leave: _get_chap_secret_for_host: host name '\n              '%(host_name)s with secret %(chap_secret)s'\n              % {'host_name': host_name, 'chap_secret': chap_secret})\n\n    return chap_secret"]