["Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n\n  params.log_memory = log_memory_;\n\n  params.runner = get_runner();\n\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n\n  OpKernelContext context(&params);\n\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, /*verbose=*/false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n\n  if (!context.status().ok()) return context.status();\n\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\n\t/* disallow empty passwords */\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strncmp(md5, passwd, MD5_PASSWD_LEN) == 0;\n\t}\n\treturn false;\n}", "static void rds_tcp_kill_sock(struct net *net)\n{\n    struct rds_tcp_connection *tc, *_tc;\n    struct sock *sk;\n    LIST_HEAD(tmp_list);\n    struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\n    rds_tcp_listen_stop(rtn->rds_tcp_listen_sock);\n    rtn->rds_tcp_listen_sock = NULL;\n    flush_work(&rtn->rds_tcp_accept_w);\n    spin_lock_bh(&rds_tcp_conn_lock);\n    list_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n        struct net *c_net = read_pnet(&tc->conn->c_net);\n\n        if (net != c_net)\n            continue;\n        list_move_tail(&tc->t_tcp_node, &tmp_list);\n    }\n    spin_unlock_bh(&rds_tcp_conn_lock);\n    list_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node) {\n        sk = tc->t_sock->sk;\n        sk->sk_prot->disconnect(sk, 0);\n        tcp_done(sk);\n        if (tc->conn->c_passive)\n            rds_conn_destroy(tc->conn->c_passive);\n        rds_conn_destroy(tc->conn);\n    }\n}", "static Image *ReadXCFImage(const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent, GetMagickModule(), \"%s\", image_info->filename);\n  assert(exception != NULL);\n  assert(exception->signature == MagickSignature);\n  image = AcquireImage(image_info);\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n  {\n    image = DestroyImageList(image);\n    return NULL;\n  }\n  count = ReadBlob(image, 14, (unsigned char *) magick);\n  if ((count != 14) || (LocaleNCompare((char *) magick, \"gimp xcf\", 8) != 0))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info, 0, sizeof(XCFDocInfo));\n  doc_info.exception = exception;\n  doc_info.width = ReadBlobMSBLong(image);\n  doc_info.height = ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  doc_info.image_type = ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns = doc_info.width;\n  image->rows = doc_info.height;\n  image_type = doc_info.image_type;\n  doc_info.file_size = GetBlobSize(image);\n  image->compression = NoCompression;\n  image->depth = 8;\n  status = SetImageExtent(image, image->columns, image->rows);\n  if (status == MagickFalse)\n  {\n    InheritException(exception, &image->exception);\n    return DestroyImageList(image);\n  }\n  if (image_type == GIMP_RGB)\n    ;\n  else if (image_type == GIMP_GRAY)\n    image->colorspace = GRAYColorspace;\n  else if (image_type == GIMP_INDEXED)\n    ThrowReaderException(CoderError, \"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image, OpaqueOpacity);\n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n    case PROP_END:\n      foundPropEnd = 1;\n      break;\n    case PROP_COLORMAP:\n    {\n      /* Cannot rely on prop_size here--the value is set incorrectly by some Gimp versions. */\n      size_t num_colours = ReadBlobMSBLong(image);\n      if (DiscardBlobBytes(image, 3 * num_colours) == MagickFalse)\n        ThrowFileException(&image->exception, CorruptImageError, \"UnexpectedEndOfFile\", image->filename);\n      break;\n    }\n    case PROP_COMPRESSION:\n    {\n      doc_info.compression = ReadBlobByte(image);\n      if ((doc_info.compression != COMPRESS_NONE) &&\n          (doc_info.compression != COMPRESS_RLE) &&\n          (doc_info.compression != COMPRESS_ZLIB) &&\n          (doc_info.compression != COMPRESS_FRACTAL))\n        ThrowReaderException(CorruptImageError, \"UnrecognizedImageCompression\");\n    }\n    break;\n\n    case PROP_GUIDES:\n    {\n      /* just skip it - we don't care about guides */\n      if (DiscardBlobBytes(image, prop_size) == MagickFalse)\n        ThrowFileException(&image->exception, CorruptImageError, \"UnexpectedEndOfFile\", image->filename);\n    }\n    break;\n\n    case PROP_RESOLUTION:\n    {\n      /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n      /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n    }\n    break;\n\n    case PROP_TATTOO:\n    {\n      /* we need to read it, even if we ignore it */\n      /* size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n    }\n    break;\n\n    case PROP_PARASITES:\n    {\n      /* BOGUS: we may need these for IPTC stuff */\n      if (DiscardBlobBytes(image, prop_size) == MagickFalse)\n        ThrowFileException(&image->exception, CorruptImageError, \"UnexpectedEndOfFile\", image->filename);\n    }\n    break;\n\n    case PROP_UNIT:\n    {\n      /* BOGUS: ignore for now... */\n      /* size_t unit =  */ (void) ReadBlobMSBLong(image);\n    }\n    break;\n\n    case PROP_PATHS:\n    {\n      /* BOGUS: just skip it for now */\n      if (DiscardBlobBytes(image, prop_size) == MagickFalse)\n        ThrowFileException(&image->exception, CorruptImageError, \"UnexpectedEndOfFile\", image->filename);\n    }\n    break;\n\n    case PROP_USER_UNIT:\n    {\n      char unit_string[1000];\n      /*BOGUS: ignored for now */\n      /* float  factor = (float) */ (void) ReadBlobMSBLong(image);\n      /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n      for (i = 0; i < 5; i++)\n        (void) ReadBlobStringWithLongSize(image, unit_string, sizeof(unit_string));\n    }\n    break;\n\n    default:\n    {\n      int buf[16];\n      ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount = (ssize_t) MagickMin(16, prop_size);\n        amount = (ssize_t) ReadBlob(image, (size_t) amount, (unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError, \"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16, (size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n  {\n    ; /* do nothing, were just pinging! */\n  }\n  else\n  {\n    int\n      current_layer = 0,\n      foundAllLayers = MagickFalse,\n      number_layers = 0;\n\n    MagickOffsetType\n      oldPos = TellBlob(image);\n\n    XCFLayerInfo\n      *layer_info;\n\n    /*\n      The read pointer.\n    */\n    do\n    {\n      ssize_t offset = ReadBlobMSBSignedLong(image);\n      if (offset == 0)\n        foundAllLayers = MagickTrue;\n      else\n        number_layers++;\n      if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception, CorruptImageError, \"UnexpectedEndOfFile\", image->filename);\n        break;\n      }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers = number_layers;\n    offset = SeekBlob(image, oldPos, SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length = (size_t) number_layers;\n    layer_info = (XCFLayerInfo *) AcquireQuantumMemory(length, sizeof(*layer_info));\n    if (layer_info == NULL)\n      ThrowReaderException(ResourceLimitError, \"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info, 0, number_layers * sizeof(XCFLayerInfo));\n    for (;;)\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset = (MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos = TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image, offset, SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError, \"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok = ReadOneLayer(image_info, image, &doc_info, &layer_info[current_layer], current_layer);\n      if (layer_ok == MagickFalse)\n      {\n        int j;\n\n        for (j = 0; j < current_layer; j++)\n          layer_info[j].image = DestroyImage(layer_info[j].image);\n        layer_info = (XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n        ThrowReaderException(ResourceLimitError, \"MemoryAllocationFailed\");\n      }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset = SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n\n    while (number_layers--)\n      DestroyImageStack(&layer_info[number_layers].image);\n    layer_info = (XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n  }\n\n  (void) CloseBlob(image);\n  DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type = GrayscaleType;\n  return GetFirstImageInList(image);\n}", "```c\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info) {\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    num_key_aliases = 0;\n    for(i = 0; i < darray_size(info->aliases); i++) {\n        alias = darray_item(info->aliases, i);\n        \n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                KeyNameText(info->ctx, alias->alias),\n                KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                \"Attempt to create alias with the name of a real key; \"\n                \"Alias \\\"%s = %s\\\" ignored\\n\",\n                KeyNameText(info->ctx, alias->alias),\n                KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n\n    i = 0;\n    for(i = 0; i < darray_size(info->aliases); i++) {\n        alias = darray_item(info->aliases, i);\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n```", "void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & (IFF_TUN | IFF_TAP)) {\n\t\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\t\ttun = netdev_priv(dev);\n\t\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\t\ttun = netdev_priv(dev);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\t\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need to initialize the device again. */\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (ifr->ifr_flags & (IFF_TUN | IFF_TAP)) {\n\t\t\tflags |= ifr->ifr_flags & (IFF_TUN | IFF_TAP);\n\t\t\tname = (ifr->ifr_name && *ifr->ifr_name) ? ifr->ifr_name : flags & IFF_TUN ? \"tun%d\" : \"tap%d\";\n\n\t\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name, NET_NAME_UNKNOWN, tun_setup, queues, queues);\n\n\t\t\tif (!dev)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\terr = dev_get_valid_name(net, dev, name);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_dev;\n\n\t\t\tdev_net_set(dev, net);\n\t\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\t\tdev->ifindex = tfile->ifindex;\n\t\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\t\ttun = netdev_priv(dev);\n\t\t\ttun->dev = dev;\n\t\t\ttun->flags = flags;\n\t\t\ttun->txflt.count = 0;\n\t\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\t\ttun->align = NET_SKB_PAD;\n\t\t\ttun->filter_attached = false;\n\t\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\t\ttun->rx_batched = 0;\n\t\t\t\n\t\t\t// Remaining code remains unchanged due to the fixing of the security vulnerability\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\n\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\n\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}", "Function Name: WriteImages\nFixed Code:\nMagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n  ExceptionInfo\n    *sans_exception = (ExceptionInfo *) NULL;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed = MagickTrue;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent, GetMagickModule(), \"%s\", images->filename);\n  assert(exception != NULL);\n  write_info = CloneImageInfo(image_info);\n  *write_info->magick = '\\0';\n  images = GetFirstImageInList(images);\n  if (filename != NULL)\n    for (p = images; p != NULL; p = GetNextImageInList(p))\n      (void) CopyMagickString(p->filename, filename, MagickPathExtent);\n  (void) CopyMagickString(write_info->filename, images->filename, MagickPathExtent);\n  sans_exception = AcquireExceptionInfo();\n  (void) SetImageInfo(write_info, (unsigned int) GetImageListLength(images), sans_exception);\n  sans_exception = DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick, images->magick, MagickPathExtent);\n  p = images;\n  for (; GetNextImageInList(p) != NULL; p = GetNextImageInList(p))\n    if (p->scene >= GetNextImageInList(p)->scene)\n    {\n      register ssize_t\n        i;\n\n      /*\n        Generate consistent scene numbers.\n      */\n      i = (ssize_t) images->scene;\n      for (p = images; p != NULL; p = GetNextImageInList(p))\n        p->scene = (size_t) i++;\n      break;\n    }\n  /*\n    Write images.\n  */\n  status = MagickTrue;\n  progress_monitor = NULL;\n  progress = 0;\n  number_images = GetImageListLength(images);\n  for (p = images; p != NULL; p = GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor = SetImageProgressMonitor(p, NULL, p->client_data);\n    status &= WriteImage(write_info, p, exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p, progress_monitor, p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n    {\n      proceed = SetImageProgress(p, \"Write/Image\", progress++, number_images);\n      if (proceed == MagickFalse)\n        break;\n    }\n  }\n  write_info = DestroyImageInfo(write_info);\n  return (status != 0 ? MagickTrue : MagickFalse);\n}"]