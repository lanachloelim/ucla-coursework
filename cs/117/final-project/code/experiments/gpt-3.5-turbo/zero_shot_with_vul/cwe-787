["static ssize_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate)\n{\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  PixelPacket\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n  compact_pixels=(PixelPacket *) NULL;\n  if (next_image->compression == RLECompression)\n    {\n      compact_pixels=AcquirePixelCache(next_image, 0, 0, next_image->columns, next_image->rows);\n      if (compact_pixels == (PixelPacket *) NULL)\n        return(0);\n    }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if (next_image->storage_class != PseudoClass)\n        {\n          if (IsGrayImage(next_image,&next_image->exception) == MagickFalse)\n            channels=next_image->colorspace == CMYKColorspace ? 4 : 3;\n          if (next_image->matte != MagickFalse)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if (next_image->storage_class == PseudoClass)\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n    else\n    {\n      if (IsGrayImage(next_image,&next_image->exception) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n        else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateImage(next_image,MagickFalse);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n          {\n            length=WritePSDChannel(psd_info,image_info,image,next_image,\n              BlackQuantum,compact_pixels,rows_offset,separate);\n            if (separate != MagickFalse)\n              size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n            else\n              rows_offset+=offset_length;\n            count+=length;\n          }\n        }\n        if (next_image->matte != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      }\n      compact_pixels=(PixelPacket *) RelinquishMagickMemory(compact_pixels);\n      if (next_image->colorspace == CMYKColorspace)\n        (void) NegateImage(next_image,MagickFalse);\n      if (separate != MagickFalse)\n      {\n        const char\n          *property;\n\n        property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n        if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            &image->exception);\n          if (mask != (Image *) NULL)\n          {\n            if (mask->compression == RLECompression)\n            {\n              compact_pixels=AcquirePixelCache(mask, 0, 0, mask->columns, mask->rows);\n              if (compact_pixels == (PixelPacket *) NULL)\n                return(0);\n            }\n            length=WritePSDChannel(psd_info,image_info,image,mask,\n              RedQuantum,compact_pixels,rows_offset,MagickTrue);\n            (void) WritePSDSize(psd_info,image,length,size_offset);\n            count+=length;\n            compact_pixels=(PixelPacket *) RelinquishMagickMemory(\n              compact_pixels);\n          }\n        }\n      }\n      return(count);\n    }", "Function Name: InitialiseRFBConnection\nVulnerability: cwe-787\nCode:\nInitialiseRFBConnection(rfbClient* client)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  uint32_t authScheme;\n  uint32_t subAuthScheme;\n  rfbClientInitMsg ci;\n  \n  /* validate pv length before null terminating */\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n  if (pv[sz_rfbProtocolVersionMsg - 1] != '\\0') {\n    rfbClientLog(\"Protocol version message buffer not null terminated\\n\");\n    return FALSE;\n  }\n\n  errorMessageOnReadFailure = TRUE;\n\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2) {\n    rfbClientLog(\"Not a valid VNC server (%s)\\n\",pv);\n    return FALSE;\n  }\n\n  DefaultSupportedMessages(client);\n  client->major = major;\n  client->minor = minor;\n\n  if ((major==rfbProtocolMajorVersion) && (minor>rfbProtocolMinorVersion))\n    client->minor = rfbProtocolMinorVersion;\n\n  if (major==3 && (minor==4 || minor==6)) {\n      rfbClientLog(\"UltraVNC server detected, enabling UltraVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  if (major==3 && (minor==14 || minor==16)) {\n     minor = minor - 10;\n     client->minor = minor;\n     rfbClientLog(\"UltraVNC Single Click server detected, enabling UltraVNC specific messages\\n\",pv);\n     DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  if (major==3 && minor==5) {\n      rfbClientLog(\"TightVNC server detected, enabling TightVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesTightVNC(client);\n  }\n\n  if ((major==3 && minor>8) || major>3)\n  {\n    client->major=3;\n    client->minor=8;\n  }\n\n  rfbClientLog(\"VNC server supports protocol version %d.%d (viewer %d.%d)\\n\",\n      major, minor, rfbProtocolMajorVersion, rfbProtocolMinorVersion);\n\n  sprintf(pv,rfbProtocolVersionFormat,client->major,client->minor);\n\n  if (!WriteToRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n\n  /* handle different authentication schemes */\n  if (client->major==3 && client->minor > 6)\n  {\n    if (!ReadSupportedSecurityType(client, &authScheme, FALSE)) return FALSE;\n  }\n  else\n  {\n    if (!ReadFromRFBServer(client, (char *)&authScheme, 4)) return FALSE;\n    authScheme = rfbClientSwap32IfLE(authScheme);\n  }\n  \n  rfbClientLog(\"Selected Security Scheme %d\\n\", authScheme);\n  client->authScheme = authScheme;\n\n  switch (authScheme) {\n    \n  /* handle different authentication cases */\n  \n  return TRUE;\n}", "```c\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left, info_size;\n\tcdf_property_info_t *inp;\n\n\tif (offs <= (UINT32_MAX / 4)) {\n\t\terrno = EFTYPE;\n\t\treturn -1;\n\t}\n\tshp = (const cdf_section_header_t *) cdf_offset(sst->sst_tab, offs);\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1) {\n\t\treturn -1;\n\t}\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\treturn -1;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1) {\n\t\treturn -1;\n\t}\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT) {\n\t\treturn -1;\n\t}\n\tinfo_size = (*maxcount - *count) * sizeof(cdf_property_info_t);\n\tinp = realloc(*info, info_size + (sh.sh_properties * sizeof(cdf_property_info_t)));\n\tif (inp == NULL) {\n\t\tfree(*info);\n\t\t*info = NULL;\n\t\t*count = 0;\n\t\t*maxcount = 0;\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\t*info = inp;\n\t*count += sh.sh_properties;\n\tp = (const uint8_t *) cdf_offset(sst->sst_tab, offs + sizeof(sh));\n\te = (const uint8_t *) cdf_offset(shp, sh.sh_len);\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = (size_t)(e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\t// rest of the code remains the same\n\t}\n\treturn 0;\n}\n```", "```c\nopj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    FILE *f = NULL;\n    int w, h, prec;\n    int i, numcomps, max;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */\n    opj_image_t * image = NULL;\n    int adjustS, ushift, dshift, force8;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n\n    char temp[32];\n    int bigendian;\n    opj_image_comp_t *comp = NULL;\n\n    numcomps = 1;\n    color_space = OPJ_CLRSPC_GRAY;\n\n    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));\n\n    max = 0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !\\n\", filename);\n        return NULL;\n    }\n\n    fseek(f, 0, SEEK_SET);\n    if (fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {\n        fclose(f);\n        fprintf(stderr,\n                \"ERROR: Failed to read the right number of element from the fscanf() function!\\n\");\n        return NULL;\n    }\n\n    i = 0;\n    sign = '+';\n    while (signtmp[i] != '\\0') {\n        if (signtmp[i] == '-') {\n            sign = '-';\n        }\n        i++;\n    }\n\n    fgetc(f);\n    if (endian1 == 'M' && endian2 == 'L') {\n        bigendian = 1;\n    } else if (endian2 == 'M' && endian1 == 'L') {\n        bigendian = 0;\n    } else {\n        fclose(f);\n        fprintf(stderr, \"Bad pgx header, please check input file\\n\");\n        return NULL;\n    }\n\n    /* initialize image component */\n\n    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +\n                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx\n                 + 1;\n    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +\n                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy\n                 + 1;\n\n    if (sign == '-') {\n        cmptparm.sgnd = 1;\n    } else {\n        cmptparm.sgnd = 0;\n    }\n    if (prec < 8) {\n        force8 = 1;\n        ushift = 8 - prec;\n        dshift = prec - ushift;\n        if (cmptparm.sgnd) {\n            adjustS = (1 << (prec - 1));\n        } else {\n            adjustS = 0;\n        }\n        cmptparm.sgnd = 0;\n        prec = 8;\n    } else {\n        ushift = dshift = force8 = adjustS = 0;\n    }\n\n    cmptparm.prec = (OPJ_UINT32)prec;\n    cmptparm.bpp = (OPJ_UINT32)prec;\n    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;\n    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = cmptparm.x0;\n    image->y0 = cmptparm.x0;\n    image->x1 = cmptparm.w;\n    image->y1 = cmptparm.h;\n\n    /* set image data */\n\n    comp = &image->comps[0];\n\n    for (i = 0; i < w * h; i++) {\n        int v;\n        if (force8) {\n            v = readuchar(f) + adjustS;\n            v = (v << ushift) + (v >> dshift);\n            comp->data[i] = (unsigned char)v;\n\n            if (v > max) {\n                max = v;\n            }\n\n            continue;\n        }\n        if (comp->prec == 8) {\n            if (!comp->sgnd) {\n                v = readuchar(f);\n            } else {\n                v = (char) readuchar(f);\n            }\n        } else if (comp->prec <= 16) {\n            if (!comp->sgnd) {\n                v = readushort(f, bigendian);\n            } else {\n                v = (short) readushort(f, bigendian);\n            }\n        } else {\n            if (!comp->sgnd) {\n                v = (int)readuint(f, bigendian);\n            } else {\n                v = (int) readuint(f, bigendian);\n            }\n        }\n        if (v > max) {\n            max = v;\n        }\n        comp->data[i] = v;\n    }\n    fclose(f);\n    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;\n\n    return image;\n}\n```", "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n    size_t length;\n    unsigned char *datum;\n    unsigned int count, long_sans;\n    unsigned short id, short_sans;\n\n    length = GetStringInfoLength(bim_profile);\n    if (length < 16)\n        return;\n    datum = GetStringInfoDatum(bim_profile);\n    for (const unsigned char *p = datum; p < (datum + length - 16);)\n    {\n        unsigned char *q;\n        q = (unsigned char *)p;\n        if (LocaleNCompare((const char *)p, \"8BIM\", 4) != 0)\n            break;\n        p = PushLongPixel(MSBEndian, p, &long_sans);\n        p = PushShortPixel(MSBEndian, p, &id);\n        p = PushShortPixel(MSBEndian, p, &short_sans);\n        p = PushLongPixel(MSBEndian, p, &count);\n        if (id == 0x0000040f)\n        {\n            memmove(q, q + PSDQuantum(count) + 12, length - (PSDQuantum(count) + 12) - (q - datum));\n            SetStringInfoLength(bim_profile, length - (PSDQuantum(count) + 12));\n            break;\n        }\n        p += count;\n        if ((count & 0x01) != 0)\n            p++;\n    }\n}"]