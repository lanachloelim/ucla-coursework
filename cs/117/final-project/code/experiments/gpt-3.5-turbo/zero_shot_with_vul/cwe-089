["    def likeComments(self, commentid, userid):\n        sqlText=\"insert into comment_like values(%s,%s);\"\n        result=sql.insertDB(self.conn, sqlText, (str(userid), str(commentid)))\n        return result;", "def add_inverters(self):\n    interfaces = self.config.get_connection_interfaces()\n    for source in interfaces:\n        if source[\"type\"] == \"inverter\":\n            query = '''\n                INSERT OR IGNORE INTO Inverters (\n                    Serial,\n                    EToday,\n                    ETotal\n                ) VALUES (\n                    %s,\n                    %s,\n                    %s\n                );\n            '''\n            values = (source[\"serial_id\"], 0, source[\"prev_etotal\"])\n            self.c.execute(query, values)\n\n            query = '''\n                UPDATE Inverters\n                SET     \n                    Name=?, \n                    Type=?, \n                    SW_Version=?, \n                    Status=?,\n                    TimeStamp=?\n                WHERE Serial=?;\n            '''\n            values = (source[\"name\"], source[\"inverter_type\"], \"s0-bridge v0\", \"OK\", int(datetime.now().timestamp()), source[\"serial_id\"])\n            self.c.execute(query, values)\n\n            self.db.commit()", "@mod.route('/delete/<int:msg_id>', methods=['GET', 'POST'])\ndef delete(msg_id):\n    if request.method == 'POST':\n        sql = \"DELETE FROM message where msg_id = %s;\"\n        cursor.execute(sql, (msg_id,)) \n        conn.commit()\n        flash('Delete Success!')\n    return redirect(url_for('show_entries'))", "def karma_rank(name):\n    db = db_connect()\n    cursor = db.cursor()\n    try:\n        query = \"SELECT COUNT(*) FROM people AS t2 WHERE t2.karma > (SELECT karma FROM people AS t3 WHERE t3.name= %s)\"\n        cursor.execute(query, (name,))\n        rank = cursor.fetchone()[0] + 1\n        logger.debug('Rank of {} found for name {}'.format(rank, name))\n        cursor.close()\n        db.close()\n        return rank\n    except MySQLdb.Error as e:\n        logger.error('Execution failed with error: {}'.format(e))\n        raise\nNote: This code uses parameterized query to fix the SQL Injection vulnerability CWE-089.", "def get_last_month(db, scene):\n    sql = \"select date from matches where scene=%s order by date desc limit 1;\"\n    res = db.execute(sql, (scene,))\n    date = res.fetchone()[0]\n\n    current_date = datetime.datetime.today().strftime('%Y-%m-%d')\n    current_year, current_month, _ = map(int, current_date.split('-'))\n    date_year, date_month, _ = map(int, date.split('-'))\n\n    if current_year > date_year or current_month > date_month:\n        date = get_next_month(date)\n\n    return date", "```python\n@app.route('/players/<int:player_id>/achievements')\ndef achievements_list_player(player_id):\n    \"\"\"Lists the progress of achievements for a player.\n\n    :param player_id: ID of the player.\n\n    :return:\n        If successful, this method returns a response body with the following structure::\n\n            {\n              \"items\": [\n                {\n                  \"achievement_id\": string,\n                  \"state\": string,\n                  \"current_steps\": integer,\n                  \"create_time\": long,\n                  \"update_time\": long\n                }\n              ]\n            }\n    \"\"\"\n    with db.connection:\n        cursor = db.connection.cursor(db.pymysql.cursors.DictCursor)\n        cursor.execute(\"\"\"SELECT\n                            achievement_id,\n                            current_steps,\n                            state,\n                            UNIX_TIMESTAMP(create_time) as create_time,\n                            UNIX_TIMESTAMP(update_time) as update_time\n                        FROM player_achievements\n                        WHERE player_id = %s\"\"\", (player_id,))\n\n        return flask.jsonify(items=cursor.fetchall())\n```", "def check_if_this_project_is_in_database(self, project_id):\n        self.cursor.execute(\"SELECT count(id) FROM projects where id = %s\", (project_id,))\n        return self.cursor.fetchone()[0] == 1", "@app.route(\"/<page_name>/edit\")\ndef edit_page(page_name):\n    query = db.query(\"select * from page where title = %s\", (page_name,)).namedresult()\n    if len(query) == 0:\n        return render_template(\n            \"edit.html\",\n            page_name=page_name,\n            query=query\n        )\n    else:\n        return render_template(\n            \"edit.html\",\n            page_name=page_name,\n            query=query[0]\n        )", "def reportMatch(winner, loser):\n    \"\"\"Records the outcome of a single match between two players.\n\n    Args:\n      winner:  the id number of the player who won\n      loser:  the id number of the player who lost\n    \"\"\"\n    conn = connect()\n    cursor = conn.cursor()\n    cursor.execute(\"INSERT INTO playsRecord (winner, loser) VALUES (?, ?)\", (winner, loser))\n    conn.commit()\n    conn.close()", "def get_game_info(conn, game):\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT player1, player2, size, state FROM games WHERE id = %s;\", (game,))\n    if cursor.rowcount != 1:\n        raise FormError(\"Invalid game ID\")\n    \n    row = cursor.fetchone()\n    players = [row[0], row[1]\n    size = row[2]\n    state = row[3] if row[3] is not None else \"Active\"\n    \n    cursor.close()\n    \n    return (players, size, state)", "```python\nimport re\nfrom some_module import logger, create_connection, pd, datetime\n\ndef process_as_reply(email_obj):\n    job_number = email_obj['subject'].split(': #')[1]\n    feedback = re.findall(r\"^[\\W]*([Oo\\d]){1}(?=[\\W]*)\", email_obj['content'].replace('#','').replace('link', ''))[0]\n\n    feedback = 1 if feedback in ['O', 'o'] else int(feedback)\n    dcn_key = re.findall(r'\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}', email_obj['content'])[0]\n    logger.info(f\"got feedback `{feedback}` for job #{job_number\")\n\n    with create_connection() as conn:\n        was_prev_closed = pd.read_sql(f\"SELECT * FROM df_dilfo WHERE job_number={job_number}\", conn).iloc[0].closed\n\n    if was_prev_closed:\n        logger.info(\"job was already matched successfully and logged as `closed`... skipping.\")\n        return\n\n    if feedback == 1:\n        logger.info(f\"got feedback that DCN key {dcn_key} was correct\")\n        update_status_query = f\"UPDATE df_dilfo SET closed = 1 WHERE job_number = {job_number}\"\n        \n        with create_connection() as conn:\n            conn.cursor().execute(update_status_query)\n\n        logger.info(f\"updated df_dilfo to show `closed` status for job #{job_number}\")\n\n    with create_connection() as conn:\n        df = pd.read_sql(\"SELECT * FROM df_matched\", conn)\n        match_dict_input = {\n            'job_number': job_number,\n            'dcn_key': dcn_key,\n            'ground_truth': int(feedback == 1),\n            'multi_phase': int(feedback == 2),\n            'verifier': email_obj[\"sender\"],\n            'source': 'feedback',\n            'log_date': str(datetime.datetime.now().date()),\n            'validate': 0,\n        }\n        df = df.append(match_dict_input, ignore_index=True)\n        df = df.drop_duplicates(subset=[\"job_number\", \"dcn_key\"], keep='last')\n        df.to_sql('df_matched', conn, if_exists='replace', index=False)\n        logger.info(\n            f\"DCN key `{dcn_key}` was a \"\n            f\"{'successful match' if feedback == 1 else 'mis-match'} for job \"\n            f\"#{job_number}\"\n        )\n```", "def update_playlist(id, name, db):\n    db.execute(\n        \"UPDATE playlist SET name=? WHERE id=?;\", (name, id))", "def get_requested_month(self, date):\n    data = dict()\n\n    month_start, month_end = self.get_epoch_month(date)\n    data['interval'] = {'from': self.convert_local_ts_to_utc(month_start, self.local_timezone), 'to': self.convert_local_ts_to_utc(month_end, self.local_timezone)}\n    month_total = 0\n\n    query = '''\n        SELECT TimeStamp, SUM(DayYield) AS Power \n        FROM MonthData \n        WHERE TimeStamp BETWEEN ? AND ?\n        GROUP BY TimeStamp\n        '''\n\n    data['data'] = list()\n    for row in self.c.execute(query, (month_start, month_end)):\n        data['data'].append({'time': self.convert_local_ts_to_utc(row[0], self.local_timezone), 'power': row[1]})\n        month_total += row[1]\n\n    data['total'] = month_total\n\n    query = '''\n        SELECT MIN(TimeStamp) as Min, MAX(TimeStamp) as Max \n        FROM ( SELECT TimeStamp FROM MonthData GROUP BY TimeStamp );\n        '''\n\n    self.c.execute(query)\n    first_data, last_data = self.c.fetchone()\n\n    if first_data: data['hasPrevious'] = (first_data < month_start)\n    else: data['hasPrevious'] = False\n    if last_data: data['hasNext'] = (last_data > month_end)\n    else: data['hasNext'] = False\n\n    return data", "def retrieve_videos_from_playlist(playlist_id, db):\n    db.execute(\"SELECT id, title, thumbnail, position from video WHERE playlist_id=? ORDER BY position ASC;\", (playlist_id,))\n    rows = db.fetchall()\n    return rows", "def create_playlist(name):\n    db = connect_to_database()\n    cursor = db.cursor()\n    query = \"INSERT INTO playlist (name, video_position) VALUES(%s, 0);\"\n    cursor.execute(query, (name,))\n    db.commit()\n    db.close()", "def update_video_positions(removed_position, db):\n    db.execute(\"UPDATE video SET position = position - 1 WHERE position > %s\",\n               (removed_position,))", "@staticmethod\ndef _check_camera_tags(tags):\n    \"\"\"\n    Function that convert stupid code name of a smartphone or camera\n    from EXIF to meaningful one by looking a collation in a special MySQL\n    table For example instead of just Nikon there can be\n    NIKON CORPORATION in EXIF\n\n    :param tags: name of a camera and lens from EXIF\n    :return: list with one or two strings which are name of\n    camera and/or lens. If there is not better name for the gadget\n    in database, function just returns name how it is\n    \"\"\"\n    checked_tags = []\n\n    for tag in tags:\n        if tag:  # If there was this information inside EXIF of the photo\n            tag = str(tag).strip()\n            log.info('Looking up collation for %s', tag)\n            query = 'SELECT right_tag FROM tag_table WHERE wrong_tag=?'\n            cursor = db.execute_parameterized_query(query, (tag,))\n            if not cursor:\n                log.error(\"Can't check the tag because of the db error\")\n                log.warning(\"Tag will stay as is.\")\n                continue\n            if cursor.rowcount:\n                # Get appropriate tag from the table\n                tag = cursor.fetchone()[0]\n                log.info('Tag after looking up in tag_tables - %s.', tag)\n\n        checked_tags.append(tag)\n    return checked_tags", "def add_input(self, data):\n    connection = self.connect()\n    try:\n        query = \"INSERT INTO crimes (description) VALUES(%s);\"\n        with connection.cursor() as cursor:\n            cursor.execute(query, (data,))\n            connection.commit()\n    finally:\n        connection.close()", "def getResults(poll_name):\n    conn, c = connectDB()\n    req = \"SELECT options from {} where name = %s\".format(CFG(\"poll_table_name\"))\n    c.execute(req, (poll_name,))\n    options_str = queryOne(c)\n\n    if not options_str:\n        raise LookupError(\"Poll '{}' not found in DB\".format(poll_name))\n\n    total = 0\n    options = options_str[0].split(\",\")\n    results = dict()\n    for opt in options:\n        count = getOptionCount(c, poll_name, opt)\n        total += int(count)\n        results.update({opt:count})\n\n    conn.close()\n    return (results, total)", "```python\ndef update_sources(conn, sqlite, k10plus, ai):\n    current_sources = get_all_current_sources(k10plus, ai)\n    old_sources = get_all_old_sources(conn, sqlite)\n\n    source_exists = [current_source for current_source in current_sources  if current_source in old_sources]\n\n    for old_source in old_sources:\n        if source_exists and old_source not in current_sources:\n            forbidden_sid = get_forbidden_sid(old_source)\n            message = \"The SID %s is no longer present in the current import.\\nIf this was intentional, please delete the SID from the database.\" % old_source\n            send_message(message)\n            send_message(forbidden_sid)\n\n    for current_source in current_sources:\n        if current_source not in old_sources:\n            message = \"The source %s is new in Solr.\" % current_source\n            if not source_exists:\n                logging.info(message)\n            else:\n                send_message(message)\n            sql = \"INSERT INTO source (source) VALUES (%s)\"\n            sqlite.execute(sql, (current_source,))\n            conn.commit()\n```"]