["search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\tconst size_t postfix_offset = sizeof(struct search_domain);\n\t\t\tconst u8 *postfix;\n\t\t\tif (postfix_offset > dom->len) {\n\t\t\t\t// handle error condition\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpostfix = ((u8 *) dom) + postfix_offset;\n\t\t\tconst int postfix_len = dom->len - postfix_offset;\n\t\t\tchar *newname = malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t// we ran off the end of the list and still didn't find the requested string\n\tEVUTIL_ASSERT(0);\n\treturn NULL; // unreachable; stops warnings in some compilers.\n}", "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = 0;\n\n    len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 1);\n    if (len <= 0) {\n        return 0;\n    }\n\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n\n    OPENSSL_cleanse(obj_txt, sizeof(obj_txt));\n\n    return 1;\n}", "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    \n    if (argc < 2)\n    {\n        printf(\"ERROR: Input file not provided.\\n\");\n        return 1;\n    }\n\n    // read input file\n    iplist = fopen(argv[1], \"rb\");\n    if (!iplist) {\n        printf(\"ERROR: Unable to open input file.\\n\");\n        return 1;\n    }\n\n    stat(argv[1], &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n\n    if (plist_out)\n    {\n        if (argc > 2)\n        {\n            FILE *oplist = fopen(argv[2], \"wb\");\n            if (!oplist) {\n                printf(\"ERROR: Unable to open output file.\\n\");\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    return 0;\n}", "```c\nAIRPDCAP_RET ValidateKeyLength(guint16 key_len, guint16 eapol_len) {\n    if (key_len < GROUP_KEY_MIN_LEN || key_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n    return AIRPDCAP_RET_SUCCESS;\n}\n\nAIRPDCAP_RET AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len) {\n    // existing code here\n\n    AIRPDCAP_RET keyLengthValidation = ValidateKeyLength(key_bytes_len, eapol_len);\n    if (keyLengthValidation != AIRPDCAP_RET_SUCCESS) {\n        return keyLengthValidation;\n    }\n\n    // existing code here\n}\n```", "MagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const double bias,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickSizeType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(image,exception);\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (status == MagickFalse)\n      continue;\n    \n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n\n    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    {\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        for (u=0; u < (ssize_t) width; u++)\n        {\n          if (u == (ssize_t) (width-1))\n            channel_bias[channel]+=pixels[i];\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image);\n        }\n        pixels+=GetPixelChannels(image)*image->columns;\n      }\n    }\n\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        channel_sum[channel]-=channel_bias[channel];\n        channel_bias[channel]=0.0;\n        pixels=p;\n        for (v=0; v < (ssize_t) height; v++)\n        {\n          channel_bias[channel]+=pixels[i];\n          pixels+=(width-1)*GetPixelChannels(image);\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image)*(image->columns+1);\n        }\n        mean=(double) (channel_sum[channel]/number_pixels+bias);\n        SetPixelChannel(threshold_image,channel,(Quantum) ((double)\n          p[center+i] <= mean ? 0 : QuantumRange),q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(threshold_image);\n    }\n    if (SyncCacheViewAuthenticPixels(threshold_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,AdaptiveThresholdImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_image->type=image->type;\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}", "void INST_HANDLER (lds) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// load value from RAMPD:k\n\tif (op != NULL) {\n\t\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\t\tESIL_A (\"r%d,=,\", d);\n\t}\n}", "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                if (i + 8 >= data_size)\n                    return -1;\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n\n    return -1;\n}", "static BOOL isvalidbuffer(const void* buffer, UINT32 size)\n{\n\treturn (buffer && size > 0) ? TRUE : FALSE;\n}\n\nstatic INLINE BOOL RLEDECOMPRESS(const BYTE* pbSrcBuffer, UINT32 cbSrcBuffer, BYTE* pbDestBuffer,\n                                 UINT32 rowDelta, UINT32 width, UINT32 height)\n{\n    const BYTE* pbSrc = pbSrcBuffer;\n\tconst BYTE* pbEnd;\n\tconst BYTE* pbDestEnd;\n\tBYTE* pbDest = pbDestBuffer;\n\tPIXEL temp;\n\tPIXEL fgPel = WHITE_PIXEL;\n\tBOOL fInsertFgPel = FALSE;\n\tBOOL fFirstLine = TRUE;\n\tBYTE bitmask;\n\tPIXEL pixelA, pixelB;\n\tUINT32 runLength;\n\tUINT32 code;\n\tUINT32 advance;\n\tRLEEXTRA\n\t\n\tif (!isvalidbuffer(pbSrcBuffer, cbSrcBuffer) || !isvalidbuffer(pbDestBuffer, rowDelta * height))\n\t\treturn FALSE;\n\t\n\tpbEnd = pbSrcBuffer + cbSrcBuffer;\n\tpbDestEnd = pbDestBuffer + rowDelta * height;\n\n\t/* Rest of the code remains the same */\n}", "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr)\n{\n    jp2_box_t *box;\n    int found;\n    jas_image_t *image;\n    jp2_dec_t *dec;\n    bool samedtype;\n    int dtype;\n    unsigned int i;\n    jp2_cmap_t *cmapd;\n    jp2_pclr_t *pclrd;\n    jp2_cdef_t *cdefd;\n    unsigned int channo;\n    int newcmptno;\n    int_fast32_t *lutents;\n    jp2_cmapent_t *cmapent;\n    jas_icchdr_t icchdr;\n    jas_iccprof_t *iccprof;\n\n    dec = nullptr;\n    box = nullptr;\n    image = nullptr;\n\n    JAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n    if (!(dec = jp2_dec_create()))\n    {\n        goto error;\n    }\n\n    // Get the first box. This should be a JP box.\n    if (!(box = jp2_box_get(in)))\n    {\n        jas_eprintf(\"error: cannot get box\\n\");\n        goto error;\n    }\n    if (box->type != JP2_BOX_JP)\n    {\n        jas_eprintf(\"error: expecting signature box\\n\");\n        goto error;\n    }\n    if (box->data.jp.magic != JP2_JP_MAGIC)\n    {\n        jas_eprintf(\"incorrect magic number\\n\");\n        goto error;\n    }\n    jp2_box_destroy(box);\n    box = nullptr;\n\n    // Get the second box. This should be a FTYP box.\n    if (!(box = jp2_box_get(in)))\n    {\n        goto error;\n    }\n    if (box->type != JP2_BOX_FTYP)\n    {\n        jas_eprintf(\"expecting file type box\\n\");\n        goto error;\n    }\n    jp2_box_destroy(box);\n    box = nullptr;\n\n    // Get more boxes...\n    found = 0;\n    while ((box = jp2_box_get(in)))\n    {\n        if (jas_getdbglevel() >= 1)\n        {\n            jas_eprintf(\"got box type %s\\n\", box->info->name);\n        }\n        switch (box->type)\n        {\n        case JP2_BOX_JP2C:\n            found = 1;\n            break;\n        case JP2_BOX_IHDR:\n            if (!dec->ihdr)\n            {\n                dec->ihdr = box;\n                box = nullptr;\n            }\n            break;\n        case JP2_BOX_BPCC:\n            if (!dec->bpcc)\n            {\n                dec->bpcc = box;\n                box = nullptr;\n            }\n            break;\n        case JP2_BOX_CDEF:\n            if (!dec->cdef)\n            {\n                dec->cdef = box;\n                box = nullptr;\n            }\n            break;\n        case JP2_BOX_PCLR:\n            if (!dec->pclr)\n            {\n                dec->pclr = box;\n                box = nullptr;\n            }\n            break;\n        case JP2_BOX_CMAP:\n            if (!dec->cmap)\n            {\n                dec->cmap = box;\n                box = nullptr;\n            }\n            break;\n        case JP2_BOX_COLR:\n            if (!dec->colr)\n            {\n                dec->colr = box;\n                box = nullptr;\n            }\n            break;\n        }\n        if (box)\n        {\n            jp2_box_destroy(box);\n            box = nullptr;\n        }\n        if (found)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        jas_eprintf(\"error: no code stream found\\n\");\n        goto error;\n    }\n\n    if (!(dec->image = jpc_decode(in, optstr)))\n    {\n        jas_eprintf(\"error: cannot decode code stream\\n\");\n        goto error;\n    }\n\n    // An IHDR box must be present.\n    if (!dec->ihdr)\n    {\n        jas_eprintf(\"error: missing IHDR box\\n\");\n        goto error;\n    }\n\n    // Does the number of components indicated in the IHDR box match\n    // the value specified in the code stream?\n    if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)))\n    {\n        jas_eprintf(\"warning: number of components mismatch\\n\");\n    }\n\n    // At least one component must be present.\n    if (!jas_image_numcmpts(dec->image))\n    {\n        jas_eprintf(\"error: no components\\n\");\n        goto error;\n    }\n\n    // Determine if all components have the same data type.\n    samedtype = true;\n    dtype = jas_image_cmptdtype(dec->image, 0);\n    for (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i)\n    {\n        if (jas_image_cmptdtype(dec->image, i) != dtype)\n        {\n            samedtype = false;\n            break;\n        }\n    }\n\n    // Is the component data type indicated in the IHDR box consistent\n    // with the data in the code stream?\n    if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n        (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL))\n    {\n        jas_eprintf(\"warning: component data type mismatch (IHDR)\\n\");\n    }\n\n    // Is the compression type supported?\n    if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE)\n    {\n        jas_eprintf(\"error: unsupported compression type\\n\");\n        goto error;\n    }\n\n    if (dec->bpcc)\n    {\n        // Is the number of components indicated in the BPCC box\n        // consistent with the code stream data?\n        if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n                                                    dec->image)))\n        {\n            jas_eprintf(\"warning: number of components mismatch\\n\");\n        }\n        // Is the component data type information indicated in the BPCC\n        // box consistent with the code stream data?\n        if (!samedtype)\n        {\n            for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i)\n            {\n                if (jas_image_cmptdtype(dec->image, i) !=\n                    JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i]))\n                {\n                    jas_eprintf(\"warning: component data type mismatch (BPCC)\\n\");\n                }\n            }\n        }\n        else\n        {\n            jas_eprintf(\"warning: superfluous BPCC box\\n\");\n        }\n    }\n\n    // A COLR box must be present.\n    if (!dec->colr)\n    {\n        jas_eprintf(\"error: no COLR box\\n\");\n        goto error;\n    }\n\n    switch (dec->colr->data.colr.method)\n    {\n    case JP2_COLR_ENUM:\n        jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n        break;\n    case JP2_COLR_ICC:\n        iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n                                            dec->colr->data.colr.iccplen);\n        if (!iccprof)\n        {\n            jas_eprintf(\"error: failed to parse ICC profile\\n\");\n            goto error;\n        }\n        jas_iccprof_gethdr(iccprof, &icchdr);\n        jas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n        jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n        dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n        if (!dec->image->cmprof_)\n        {\n            jas_iccprof_destroy(iccprof);\n            goto error;\n        }\n        jas_iccprof_destroy(iccprof);\n        break;\n    }\n\n    // If a CMAP box is present, a PCLR box must also be present.\n    if (dec->cmap && !dec->pclr)\n    {\n        jas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n        jp2_box_destroy(dec->cmap);\n        dec->cmap = nullptr;\n    }\n\n    // If a CMAP box is not present, a PCLR box must not be present.\n    if (!dec->cmap && dec->pclr)\n    {\n        jas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n        jp2_box_destroy(dec->pclr);\n        dec->pclr = nullptr;\n    }\n\n    // Determine the number of channels (which is essentially the number\n    // of components after any palette mappings have been applied).\n    dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n                             JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n    // Perform a basic sanity check on the CMAP box if present.\n    if (dec->cmap)\n    {\n        for (i = 0; i < dec->numchans; ++i)\n        {\n            // Is the component number reasonable?\n            if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n                                                                jas_image_numcmpts(dec->image)))\n            {\n                jas_eprintf(\"error: invalid component number in CMAP box\\n\");\n                goto error;\n            }\n            // Is the LUT index reasonable?\n            if (dec->cmap->data.cmap.ents[i].pcol >=\n                dec->pclr->data.pclr.numchans)\n            {\n                jas_eprintf(\"error: invalid CMAP LUT index\\n\");\n                goto error;\n            }\n        }\n    }\n\n    // Allocate space for the channel-number to component-number LUT.\n    if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n                                          sizeof(uint_fast16_t))))\n    {\n        jas_eprintf(\"error: no memory\\n\");\n        goto error;\n    }\n\n    if (!dec->cmap)\n    {\n        for (i = 0; i < dec->numchans; ++i)\n        {\n            dec->chantocmptlut[i] = i;\n        }\n    }\n    else\n    {\n        cmapd = &dec->cmap->data.cmap;\n        pclrd = &dec->pclr->data.pclr;\n        cdefd = &dec->cdef->data.cdef;\n        for (channo = 0; channo < cmapd->numchans; ++channo)\n        {\n            cmapent = &cmapd->ents[channo];\n            if (cmapent->map == JP2_CMAP_DIRECT)\n            {\n                dec->chantocmptlut[channo] = channo;\n            }\n            else if (cmapent->map == JP2_CMAP_PALETTE)\n            {\n                if (!pclrd->numlutents)\n                {\n                    goto error;\n                }\n                lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n                if (!lutents)\n                {\n                    goto error;\n                }\n                for (i = 0; i < pclrd->numlutents; ++i)\n                {\n                    lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n                }\n                newcmptno = jas_image_numcmpts(dec->image);\n                jas_image_depalettize(dec->image, cmapent->cmptno,\n                                      pclrd->numlutents, lutents,\n                                      JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n                dec->chantocmptlut[channo] = newcmptno;\n                jas_free(lutents);\n            }\n            else\n            {\n                jas_eprintf(\"error: invalid MTYP in CMAP box\\n\");\n                goto error;\n            }\n        }\n    }\n\n    // Ensure that the number of channels being used by the decoder\n    // matches the number of image components.\n    if (dec->numchans != jas_image_numcmpts(dec->image))\n    {\n        jas_eprintf(\"error: mismatch in number of components (%d != %d)\\n\",\n                    dec->numchans, jas_image_numcmpts(dec->image));\n        goto error;\n    }\n\n    // Mark all components as being of unknown type.\n    for (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i)\n    {\n        jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n    }\n\n    // Determine the type of each component.\n    if (dec->cdef)\n    {\n        for (i = 0; i < dec->cdef->data.cdef.numchans; ++i)\n        {\n            // Is the channel number reasonable?\n            if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans)\n            {\n                jas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n                goto error;\n            }\n            jas_image_setcmpttype(dec->image,\n                                  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n                                  jp2_getct(jas_image_clrspc(dec->image),\n                                            dec->cdef->data.cdef.ents[i].type,\n                                            dec->cdef->data.cdef.ents[i].assoc));\n        }\n    }\n    else\n    {\n        for (i = 0; i < dec->numchans; ++i)\n        {\n            jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n                                  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n        }\n    }\n\n    // Delete any components that are not of interest.\n    for (i = jas_image_numcmpts(dec->image); i > 0; --i)\n    {\n        if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN)\n        {\n            jas_image_delcmpt(dec->image, i - 1);\n        }\n    }\n\n    // Ensure that some components survived.\n    if (!jas_image_numcmpts(dec->image))\n    {\n        jas_eprintf(\"error: no components\\n\");\n        goto error;\n    }\n\n    // Prevent the image from being destroyed later.\n    image = dec->image;\n    dec->image = nullptr;\n\n    jp2_dec_destroy(dec);\n\n    return image;\n\nerror:\n    if (box)\n    {\n        jp2_box_destroy(box);\n    }\n    if (dec)\n    {\n        jp2_dec_destroy(dec);\n    }\n    return nullptr;\n}", "static inline void get_conn_text(const conn *c, const int af, char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af, &((struct sockaddr_in *)sock_addr)->sin_addr, addr_text, sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af, &((struct sockaddr_in6 *)sock_addr)->sin6_addr, addr_text + 1, sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n\n        case AF_UNIX:\n            strncpy(addr_text, ((struct sockaddr_un *)sock_addr)->sun_path, sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n\n    if (strlen(addr_text) < 2) {\n        /* Most likely this is a connected UNIX-domain client which\n         * has no peer socket address, but there's no portable way\n         * to tell for sure.\n         */\n        snprintf(addr_text, sizeof(addr_text), \"<AF %d>\", af);\n    }\n\n    if (port) {\n        snprintf(addr, MAXPATHLEN, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        snprintf(addr, MAXPATHLEN, \"%s:%s\", protoname, addr_text);\n    }\n}", "static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len)\n{\n    const int df_idx[8] = {SC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE, SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE, SC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};\n    const int ef_idx[8] = {SC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE, SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE, -1, SC_AC_OP_ERASE, -1};\n    const int efi_idx[8] = {SC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE, SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE, -1, SC_AC_OP_ERASE, -1};\n\n    u8 bValue;\n    int i, iKeyRef = 0, iMethod, iPinCount, iOffset = 0, iOperation;\n    const int *p_idx;\n\n    while (len > 1) {\n        size_t iACLen = buf[iOffset] & 0x0F;\n        if (iACLen > len)\n            break;\n\n        iMethod = SC_AC_NONE;\n\n        if (buf[iOffset] & 0x80) {\n            size_t iParmLen = 1;\n            size_t iKeyLen = 0;\n\n            if (buf[iOffset] & 0x20)\n                iKeyLen++;\n            if (buf[iOffset + 1] & 0x40)\n                iParmLen++;\n            if (buf[iOffset + 1] & 0x20)\n                iParmLen++;\n            if (buf[iOffset + 1] & 0x10)\n                iParmLen++;\n            if (buf[iOffset + 1] & 0x08)\n                iParmLen++;\n\n            if (iKeyLen) {\n                int iSC;\n                if (len < 1 + (size_t) iACLen)\n                    break;\n                iSC = buf[iOffset + iACLen];\n\n                switch ((iSC >> 5) & 0x03) {\n                    case 0:\n                        iMethod = SC_AC_TERM;\n                        break;\n                    case 1:\n                        iMethod = SC_AC_AUT;\n                        break;\n                    case 2:\n                    case 3:\n                        iMethod = SC_AC_PRO;\n                        break;\n                }\n                iKeyRef = iSC & 0x1F;\n            }\n\n            if (iACLen > (1 + iParmLen + iKeyLen)) {\n                if (len < 1 + 1 + 1 + (size_t) iParmLen)\n                    break;\n                iKeyRef = buf[iOffset + 1 + 1 + iParmLen];\n                iMethod = SC_AC_CHV;\n            }\n\n            if (len < 1 + 2)\n                break;\n            switch (buf[iOffset + 2]) {\n                case 0x2A:\n                    iOperation = SC_AC_OP_CRYPTO;\n                    break;\n                case 0x46:\n                    iOperation = SC_AC_OP_UPDATE;\n                    break;\n                default:\n                    iOperation = SC_AC_OP_SELECT;\n                    break;\n            }\n            sc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);\n        } else {\n            switch (file->type) {\n                case SC_FILE_TYPE_DF:\n                    p_idx = df_idx;\n                    break;\n                case SC_FILE_TYPE_INTERNAL_EF:\n                    p_idx = efi_idx;\n                    break;\n                default:\n                    p_idx = ef_idx;\n                    break;\n            }\n\n            iPinCount = iACLen - 1;\n\n            if (buf[iOffset] & 0x20) {\n                int iSC;\n                if (len < 1 + (size_t) iACLen)\n                    break;\n                iSC = buf[iOffset + iACLen];\n\n                switch ((iSC >> 5) & 0x03) {\n                    case 0:\n                        iMethod = SC_AC_TERM;\n                        break;\n                    case 1:\n                        iMethod = SC_AC_AUT;\n                        break;\n                    case 2:\n                    case 3:\n                        iMethod = SC_AC_PRO;\n                        break;\n                }\n                iKeyRef = iSC & 0x1F;\n                iPinCount--;\n            }\n\n            if (iPinCount > 0) {\n                if (len < 1 + 2)\n                    break;\n                iKeyRef = buf[iOffset + 2];\n                iMethod = SC_AC_CHV;\n            }\n\n            bValue = buf[iOffset + 1];\n            for (i = 0; i < 8; i++) {\n                if ((bValue & 1) && (p_idx[i] >= 0))\n                    sc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);\n                bValue >>= 1;\n            }\n        }\n        iOffset += iACLen + 1;\n        len -= iACLen + 1;\n    }\n}", "do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n\tint os_style = -1;\n\tchar sbuf[512];\n\tstruct NetBSD_elfcore_procinfo pi;\n\tsize_t i, j, k;\n\tunsigned char c;\n\tunsigned char *cname, *cp;\n\t\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\t\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n\t\tos_style = OS_STYLE_NETBSD;\n\t}\n\n\tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n\t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n\t\t    == -1)\n\t\t\treturn 1;\n\t\t*flags |= FLAGS_DID_CORE_STYLE;\n\t\t*flags |= os_style;\n\t}\n\n\tswitch (os_style) {\n\tcase OS_STYLE_NETBSD:\n\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n\n\t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n\t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n\t\t\t    file_printable(sbuf, sizeof(sbuf),\n\t\t\t    CAST(char *, pi.cpi_name)),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_pid),\n\t\t\t    elf_getu32(swap, pi.cpi_euid),\n\t\t\t    elf_getu32(swap, pi.cpi_egid),\n\t\t\t    elf_getu32(swap, pi.cpi_nlwps),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_siglwp),\n\t\t\t    elf_getu32(swap, pi.cpi_signo),\n\t\t\t    elf_getu32(swap, pi.cpi_sigcode)) == -1)\n\t\t\t\treturn 1;\n\n\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++, reloffset++) {\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (k = i + 1; k < NOFFSETS; k++) {\n\t\t\t\t\tsize_t no;\n\t\t\t\t\tint adjust = 1;\n\t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k); no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)&nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n\t\t\t\t\tcp--;\n\t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n\t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn 1;\n\n\t\t\ttryanother:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}", "```c\ngst_asf_demux_process_ext_content_desc (GstASFDemux * demux, const guint8 * data, guint64 size)\n{\n  /* Other known (and unused) 'text/unicode' metadata available :\n   *\n   *   WM/Lyrics =\n   *   WM/MediaPrimaryClassID = {D1607DBC-E323-4BE2-86A1-48A42A28441E}\n   *   WMFSDKVersion = 9.00.00.2980\n   *   WMFSDKNeeded = 0.0.0.0000\n   *   WM/UniqueFileIdentifier = AMGa_id=R    15334;AMGp_id=P     5149;AMGt_id=T  2324984\n   *   WM/Publisher = 4AD\n   *   WM/Provider = AMG\n   *   WM/ProviderRating = 8\n   *   WM/ProviderStyle = Rock (similar to WM/Genre)\n   *   WM/GenreID (similar to WM/Genre)\n   *   WM/TrackNumber (same as WM/Track but as a string)\n   *\n   * Other known (and unused) 'non-text' metadata available :\n   *\n   *   WM/EncodingTime\n   *   WM/MCDI\n   *   IsVBR\n   *\n   * We might want to read WM/TrackNumber and use atoi() if we don't have\n   * WM/Track\n   */\n\n  GstTagList *taglist;\n  guint16 blockcount, i;\n  gboolean content3D = FALSE;\n\n  struct\n  {\n    const gchar *interleave_name;\n    GstASF3DMode interleaving_type;\n  } stereoscopic_layout_map[] = {\n    {\n    \"SideBySideRF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_RL}, {\n    \"SideBySideLF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_LR}, {\n    \"OverUnderRT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL}, {\n    \"OverUnderLT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR}, {\n    \"DualStream\", GST_ASF_3D_DUAL_STREAM}\n  };\n  GST_INFO_OBJECT (demux, \"object is an extended content description\");\n\n  taglist = gst_tag_list_new_empty ();\n\n  /* Content Descriptor Count */\n  if (size < 2)\n    goto not_enough_data;\n\n  blockcount = gst_asf_demux_get_uint16 (&data, &size);\n\n  for (i = 1; i <= blockcount; ++i) {\n    const gchar *gst_tag_name;\n    guint16 datatype;\n    guint16 value_len;\n    guint16 name_len;\n    GValue tag_value = { 0, };\n    gsize in, out;\n    gchar *name;\n    gchar *name_utf8 = NULL;\n    gchar *value;\n\n    /* Descriptor */\n    if (!gst_asf_demux_get_string (&name, &name_len, &data, &size))\n      goto not_enough_data;\n\n    if (size < 2) {\n      g_free (name);\n      goto not_enough_data;\n    }\n    /* Descriptor Value Data Type */\n    datatype = gst_asf_demux_get_uint16 (&data, &size);\n\n    /* Descriptor Value (not really a string, but same thing reading-wise) */\n    if (!gst_asf_demux_get_string (&value, &value_len, &data, &size)) {\n      g_free (name);\n      goto not_enough_data;\n    }\n\n    name_utf8 =\n        g_convert (name, name_len, \"UTF-8\", \"UTF-16LE\", &in, &out, NULL);\n\n    if (name_utf8 != NULL) {\n      GST_DEBUG (\"Found tag/metadata %s\", name_utf8);\n\n      gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name (name_utf8);\n      GST_DEBUG (\"gst_tag_name %s\", GST_STR_NULL (gst_tag_name));\n\n      switch (datatype) {\n        case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING:{\n          gchar *value_utf8;\n\n          value_utf8 = g_convert (value, value_len, \"UTF-8\", \"UTF-16LE\",\n              &in, &out, NULL);\n\n          /* get rid of tags with empty value */\n          if (value_utf8 != NULL && *value_utf8 != '\\0') {\n            GST_DEBUG (\"string value %s\", value_utf8);\n\n            value_utf8[out] = '\\0';\n\n            if (gst_tag_name != NULL) {\n              if (strcmp (gst_tag_name, GST_TAG_DATE_TIME) == 0) {\n                guint year = g_ascii_strtoull (value_utf8, NULL, 10);\n\n                if (year > 0) {\n                  g_value_init (&tag_value, GST_TYPE_DATE_TIME);\n                  g_value_take_boxed (&tag_value, gst_date_time_new_y (year));\n                }\n              } else if (strcmp (gst_tag_name, GST_TAG_GENRE) == 0) {\n                guint id3v1_genre_id;\n                const gchar *genre_str;\n\n                if (sscanf (value_utf8, \"(%u)\", &id3v1_genre_id) == 1 &&\n                    ((genre_str = gst_tag_id3_genre_get (id3v1_genre_id)))) {\n                  GST_DEBUG (\"Genre: %s -> %s\", value_utf8, genre_str);\n                  g_free (value_utf8);\n                  value_utf8 = g_strdup (genre_str);\n                }\n              } else {\n                GType tag_type;\n\n                /* convert tag from string to other type if required */\n                tag_type = gst_tag_get_type (gst_tag_name);\n                g_value_init (&tag_value, tag_type);\n                if (!gst_value_deserialize (&tag_value, value_utf8)) {\n                  GValue from_val = { 0, };\n\n                  g_value_init (&from_val, G_TYPE_STRING);\n                  g_value_set_string (&from_val, value_utf8);\n                  if (!g_value_transform (&from_val, &tag_value)) {\n                    GST_WARNING_OBJECT (demux,\n                        \"Could not transform string tag to \" \"%s tag type %s\",\n                        gst_tag_name, g_type_name (tag_type));\n                    g_value_unset (&tag_value);\n                  }\n                  g_value_unset (&from_val);\n                }\n              }\n            } else {\n              /* metadata ! */\n              GST_DEBUG (\"Setting metadata\");\n              g_value_init (&tag_value, G_TYPE_STRING);\n              g_value_set_string (&tag_value, value_utf8);\n              /* If we found a stereoscopic marker, look for StereoscopicLayout\n               * metadata */\n              if (content3D) {\n                guint i;\n                if (g_str_has_prefix (name_utf8, \"StereoscopicLayout\")) {\n                  for (i = 0; i < G_N_ELEMENTS (stereoscopic_layout_map); i++) {\n                    if (g_str_equal (stereoscopic_layout_map[i].interleave_name,\n                            value_utf8)) {\n                      demux->asf_3D_mode =\n                          stereoscopic_layout_map[i].interleaving_type;\n                      GST_INFO (\"find interleave type %u\", demux->asf_3D_mode);\n                    }\n                  }\n                }\n                GST_INFO_OBJECT (demux, \"3d type is %u\", demux->asf_3D_mode);\n              } else {\n                demux->asf_3D_mode = GST_ASF_3D_NONE;\n                GST_INFO_OBJECT (demux, \"None 3d type\");\n              }\n            }\n          } else if (value_utf8 == NULL) {\n            GST_WARNING (\"Failed to convert string value to UTF8, skipping\");\n          } else {\n            GST_DEBUG (\"Skipping empty string value for %s\",\n                GST_STR_NULL (gst_tag_name));\n          }\n          g_free (value_utf8);\n          break;\n        }\n        case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY:{\n          if (gst_tag_name) {\n            if (!g_str_equal (gst_tag_name, GST_TAG_IMAGE)) {\n              GST_FIXME (\"Unhandled byte array tag %s\",\n                  GST_STR_NULL (gst_tag_name));\n              break;\n            } else {\n              asf_demux_parse_picture_tag (taglist, (const guint8 *) value,\n                  value_len);\n            }\n          }\n          break;\n        }\n        case ASF_DEMUX_DATA_TYPE_DWORD:{\n          guint uint_val = GST_READ_UINT32_LE (value);\n          \n          /* this is the track number */\n          g_value_init (&tag_value, G_TYPE_UINT);\n\n          /* WM/Track counts from 0 */\n          if (g_strcmp0 (name_utf8, \"WM/Track\") == 0)\n            ++uint_val;\n\n          g_value_set_uint (&tag_value, uint_val);\n          break;\n        }\n          /* Detect 3D */\n        case ASF_DEMUX_DATA_TYPE_BOOL:{\n          gboolean bool_val = GST_READ_UINT32_LE (value);\n\n          if (g_str_has_prefix (name_utf8, \"Stereoscopic\")) {\n            if (bool_val) {\n              GST_INFO_OBJECT (demux, \"This is 3D contents\");\n              content3D = TRUE;\n            } else {\n              GST_INFO_OBJECT (demux, \"This is not 3D contents\");\n              content3D = FALSE;\n            }\n          }\n\n          break;\n        }\n        default:{\n          GST_DEBUG (\"Skipping tag %s of type %d\", gst_tag_name, datatype);\n          break;\n        }\n      }\n\n      if (G_IS_VALUE (&tag_value)) {\n        if (gst_tag_name) {\n          GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND;\n\n          /* WM/TrackNumber is more reliable than WM/Track, since the latter\n           * is supposed to have a 0 base but is often wrongly written to start\n           * from 1 as well, so prefer WM/TrackNumber when we have it: either\n           * replace the value added earlier from WM/Track or put it first in\n           * the list, so that it will get picked up by _get_uint() */\n          if (g_strcmp0 (name_utf8, \"WM/TrackNumber\") == 0)\n            merge_mode = GST_TAG_MERGE_REPLACE;\n\n          gst_tag_list_add_values (taglist, merge_mode, gst_tag_name,\n              &tag_value, NULL);\n        } else {\n          GST_DEBUG (\"Setting global metadata %s\", name_utf8);\n          gst_structure_set_value (demux->global_metadata, name_utf8,\n              &tag_value);\n        }\n\n        g_value_unset (&tag_value);\n      }\n    }\n\n    g_free (name);\n    g_free (value);\n    g_free (name_utf8);\n  }\n\n  gst_asf_demux_add_global_tags (demux, taglist);\n\n  return GST_FLOW_OK;\n\n  /* Errors */\nnot_enough_data:\n  {\n    GST_WARNING (\"Unexpected end of data parsing ext content desc object\");\n    gst_tag_list_unref (taglist);\n    return GST_FLOW_OK;         /* not really fatal */\n  }\n}\n```", "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           /*match_exact_params=*/false);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n\n  // recvmsg() returns the number of characters received. On error, -1 is\n  // returned, with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto msg_name_extent = output.next();\n  // The returned |msg_namelen| should not exceed the buffer size.\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n\n  // A single buffer is passed from the untrusted side, copy it into the\n  // scattered buffers inside the enclave.\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    if (bytes_to_copy > 0) {\n      memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n          bytes_to_copy);\n      bytes_copied += bytes_to_copy;\n    }\n  }\n\n  auto msg_control_extent = output.next();\n  // The returned |msg_controllen| should not exceed the buffer size.\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n\n  return result;\n}", "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String& /*type*/ /* = null_string */,\n                         int /*slabid*/ /* = 0 */, int /*limit*/ /* = 100 */) {\n  auto data = Native::data<MemcacheData>(this_);\n\n  auto stats = memcached_stat(&data->m_memcache, nullptr);\n  if (stats == nullptr) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat = stats + server_id;\n    char stats_key[30] = {0};\n    size_t key_len;\n\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat);\n    if (server_stats.empty()) {\n      continue;\n    }\n\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n\n  memcached_stat_free(&data->m_memcache, stats);\n  return return_val;\n}"]