["def getKey(client):\n\t\"\"\"Retrieves the specified key for the specified client\n\tReturns an error if the key doesn't exist, obviously.\n\t\"\"\"\n\tglobal SERVER_JWT_PRIVATE_KEY\n\tglobal BAD_REQUEST\n\n\tvalidateClient(client)\n\n\tclient_pub_key = loadClientRSAKey(client)\n\ttoken_data = decodeRequestToken(request.data, client_pub_key)\n\n\t# Implement Key Name Validation\n\tif not token_data['key'].isalnum():\n\t\traise FoxlockError(BAD_REQUEST, 'Invalid key requested')\n\n\tfile_path = 'keys/%s/%s.key' % (client, token_data['key'])\n\twith open(file_path, 'r') as file:\n\t\trequested_key = file.read()\n\n\t# Key is returned in a JWT encrypted with the client's public key, so only they can decrypt it\n\tkeytoken = packJWT({'key': requested_key}, SERVER_JWT_PRIVATE_KEY, client_pub_key)\n\n\treturn keytoken", "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n\n    const QString fullFilePath = QDir::toNativeSeparators(m_FullFilePath);\n\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(fullFilePath).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(fullFilePath.toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(fullFilePath).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir object to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(fullFilePath).toStdString()));\n    }\n\n    unzClose(zfile);\n}", "static MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char *module_path;\n\n  if (filename == NULL || path == NULL || exception == NULL) {\n    return(MagickFalse);\n  }\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n\n  (void) CopyMagickString(path,filename,MaxTextExtent);\n\n  module_path=(char *) NULL;\n\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == NULL) {\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n      }\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == NULL) {\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n      }\n#endif\n      break;\n    }\n  }\n\n  if (module_path != NULL)\n    {\n      register char *p, *q;\n\n      for (p=module_path-1; p != NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MaxTextExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != NULL) {\n          *q='\\0';\n        }\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator)) {\n          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        }\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n\n  return(MagickFalse);\n}", "@staticmethod\n    def estimate_size(task_id, taken_dirs, taken_files):\n        report = AnalysisController.get_report(task_id)\n        report = report[\"analysis\"]\n        path = report[\"info\"][\"analysis_path\"]\n\n        size_total = 0\n        \n        for directory in taken_dirs:\n            destination = os.path.join(path, directory)\n            if os.path.isdir(destination):\n                size_total += get_directory_size(destination)\n\n        for filename in taken_files:\n            destination = os.path.join(path, filename)\n            if os.path.isfile(destination):\n                size_total += os.path.getsize(destination)\n\n        # estimate file size after zipping; 60% compression rate typically\n        size_estimated = size_total / 6.5\n\n        return {\n            \"size\": int(size_estimated),\n            \"size_human\": filesizeformat(size_estimated)\n        }", "def span(self, key):\n    path = os.path.join(self.namespace, key)\n    if not self.etcd.get(path).dir:\n        try:\n            self.etcd.write(path, None, dir=True, prevExist=False)\n        except etcd.EtcdAlreadyExist as err:\n            raise CSStoreExists(str(err))\n        except etcd.EtcdException as err:\n            log_error(\"Error storing key %s: [%r]\" % (key, repr(err)))\n            raise CSStoreError('Error occurred while trying to store key')", "def _get_settings(view):\n    settings = {\n        'linters': get_settings(view, 'anaconda_go_linters', []),\n        'lint_test': get_settings(view, 'anaconda_go_lint_test', False),\n        'exclude_regexps': get_settings(view, 'anaconda_go_exclude_regexps', []),\n        'max_line_length': get_settings(view, 'anaconda_go_max_line_length', 120),\n        'gocyclo_threshold': get_settings(view, 'anaconda_go_gocyclo_threshold', 10),\n        'golint_min_confidence': get_settings(view, 'anaconda_go_golint_min_confidence', 0.80),\n        'goconst_min_occurrences': get_settings(view, 'anaconda_go_goconst_min_occurrences', 3),\n        'min_const_length': get_settings(view, 'anaconda_go_min_const_length', 3),\n        'dupl_threshold': get_settings(view, 'anaconda_go_dupl_threshold', 50),\n        'path': get_working_directory(view)\n    }\n    return settings.copy()"]