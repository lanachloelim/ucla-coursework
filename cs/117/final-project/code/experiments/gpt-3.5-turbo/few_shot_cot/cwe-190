["static void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = NULL;\n    const opj_tccp_t * l_tccp = NULL;\n    const opj_image_comp_t * l_img_comp = NULL;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* preconditions */\n    assert(p_cp != NULL);\n    assert(p_image != NULL);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        OPJ_UINT32 l_dx, l_dy;\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            if (opj_uint_adds(l_img_comp->dx, l_img_comp->dx << (l_pdx + l_tccp->numresolutions - 1 - resno), &l_dx) &&\n                opj_uint_adds(l_img_comp->dy, l_img_comp->dy << (l_pdy + l_tccp->numresolutions - 1 - resno), &l_dy)) {\n            \n                *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n                *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n                l_level_no = l_tccp->numresolutions - 1 - resno;\n                l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n                l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n                l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n                l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n                l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n                l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n                l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n                py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n                l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n                l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n                l_product = l_pw * l_ph;\n                if (l_product > *p_max_prec) {\n                    *p_max_prec = l_product;\n                }\n            }\n            else {\n                return;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}"]